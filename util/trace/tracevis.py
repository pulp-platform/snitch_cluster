#!/usr/bin/env python3

# Copyright 2021 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0

# This script parses the traces generated by Snitch and creates a JSON file
# that can be visualized by
# [Trace-Viewer](https://github.com/catapult-project/catapult/tree/master/tracing)
# In Chrome, open `about:tracing` and load the JSON file to view it.
#
# This script is inspired by https://github.com/SalvatoreDiGirolamo/tracevis
# Author: Noah Huetter <huettern@student.ethz.ch>
#         Samuel Riedel <sriedel@iis.ee.ethz.ch>
#         Luca Colagrande <colluca@iis.ee.ethz.ch>

import re
import sys
import json
import argparse
from a2l import Elf

has_progressbar = True
try:
    import progressbar
except ImportError as e:
    # Do not use progressbar
    print(f'{e} --> No progress bar will be shown.', file=sys.stderr)
    has_progressbar = False


# line format:
# Snitch RTL simulation:
# 101000 82      M         0x00001000 csrr    a0, mhartid     #; comment
# CVA6 RTL simulation:
# 101ns  82      M         0000000000001000 0      301022f3     csrr   t0, misa  ...
# time   cycle   priv_lvl  pc               branch machine_insn insn
# MemPool RTL simulation:
# 101000 82      0x00001000 csrr    a0, mhartid     #; comment
# time   cycle   pc         insn
# Banshee traces:
# 00000432 00000206 0005     800101e0  x15:00000064 x15=00000065 # addi    a5, a5, 1
# cycle    instret  hard_id  pc        register                    insn
FORMATS = ['cva6', 'snitch', 'banshee']

# regex matches to groups
# 0 -> time
# 1 -> cycle
# 2 -> privilege level (RTL) / hartid (banshee)
# 3 -> pc (hex with 0x prefix)
# 4 -> instruction
# 5 -> args (RTL) / empty (cva6, banshee)
# 6 -> comment (RTL) / instruction arguments (banshee) / empty (cva6)
REGEX = {'snitch': r' *(\d+) +(\d+) +([3M1S0U]?) *(0x[0-9a-f]+) ([.\w]+) +(.+)#; (.*)',
         'cva6': r' *(\d+)ns +(\d+) +([3M1S0U]?) *([0-9a-f]+) +[01]+ +[0-9a-f]+ +([.\w]+)',
         'banshee': r' *(\d+) (\d+) (\d+) ([0-9a-f]+) *.+ +.+# ([\w\.]*)( +)(.*)'}

# regex matches a line of instruction retired by the accelerator
# 0 -> time
# 1 -> cycle
# 2 -> privilege level
# 3 -> comment
ACC_LINE_REGEX = r' *(\d+) +(\d+) +([3M1S0U]?) *#; (.*)'


# Parses the output of the `parse_line()` function into a TraceViewer
# event, formatted as a dictionary. It operates on multiple of these
# outputs, collected in a buffer `buf`.
def flush(lah, buf, **kwargs):
    elf = kwargs['elf']
    fmt = kwargs['fmt']
    use_time = kwargs['use_time']
    collapse_call_stack = kwargs['collapse_call_stack']

    # Iterate buffer entries
    events = []
    for i in range(len(buf)-1):

        (time, cyc, priv, pc, instr, args, cmt) = buf.pop(0)

        if use_time:
            next_time = int(buf[0][0])
            time = int(time)
        else:
            next_time = int(buf[0][1])
            time = int(cyc)

        # Have lookahead time to this instruction?
        next_time = lah[time] if time in lah else next_time
        duration = next_time - time

        # Get information on current instruction from addr2line
        a2l_info = elf.addr2line(pc)

        # Assemble TraceViewer event
        # Doc: https://docs.google.com/document/d/
        #      1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview
        event = {}
        # The name of the event, as displayed in Trace Viewer
        event['name'] = instr
        # The event type, 'X' indicates a "complete event"
        event['ph'] = 'X'
        # The event categories. This is a comma separated list of categories for the event.
        # The categories can be used to hide events in the Trace Viewer UI.
        event['cat'] = 'instr'
        # The tracing clock timestamp of the event. The timestamps are provided at microsecond
        # granularity.
        if use_time:
            time = time / 1000 if fmt == 'cva6' else time / 1000000
        event['ts'] = time
        # There is an extra parameter dur to specify the tracing clock duration of complete
        # events in microseconds. In Banshee, each instruction takes one cycle
        if use_time:
            duration = duration / 1000 if fmt == 'cva6' else duration / 1000000
        event['dur'] = 1 if fmt == 'banshee' else duration
        # The thread ID is used to group events in a single TraceViewer row
        if not collapse_call_stack:
            event['tid'] = a2l_info.function_stack[0]['func']
        if fmt == 'banshee':
            # Banshee stores all traces in a single file
            event['tid'] = priv
        # Additional event args
        event['args'] = {}
        event['args']['pc'] = pc
        event['args']['instr'] = f'{instr} {args}'
        if cmt:
            event['args']['comment'] = cmt
        event['args']['cycle'] = cyc
        event['args']['stack'] = a2l_info.function_stack_string(short=True)
        event['args']['line'] = a2l_info.line()

        events.append(event)
    return events


# Parses a trace line and returns an array of values extracted from the line
def parse_line(line, **kwargs):
    fmt = kwargs['fmt']

    # Compile regex
    re_line = re.compile(REGEX[fmt])

    # print(line)
    match = re_line.match(line)
    if match:
        # TODO extend CVA6 regex to extract instruction args
        if fmt == 'cva6':
            (time, cyc, priv, pc, instr) = tuple(
                [match.group(i+1).strip() for i in range(re_line.groups)])
            args = cmt = ''
        else:
            (time, cyc, priv, pc, instr, args, cmt) = tuple(
                [match.group(i+1).strip() for i in range(re_line.groups)])
        return (time, cyc, priv, pc, instr, args, cmt)

    return None


# Parses a trace file and returns a dictionary mapping the time stamp
# when every instruction is issued, to the time stamp when the instruction
# writes back.
def offload_lookahead(lines, **kwargs):
    fmt = kwargs['fmt']
    use_time = kwargs['use_time']

    # Compile regex
    re_line = re.compile(REGEX[fmt])
    re_acc_line = re.compile(ACC_LINE_REGEX)

    # dict mapping time stamp of retired instruction to time stamp of
    # accelerator complete
    lah = {}
    searches = []
    re_load = re.compile(r'([a-z]*[0-9]*|zero) *<~~ Word')

    for line in lines:
        match = re_line.match(line)
        if match:
            (time, cyc, priv, pc, instr, args, cmt) = tuple(
                [match.group(i+1).strip() for i in range(re_line.groups)])
            time = int(time) if use_time else int(cyc)

            # register searchers
            if '<~~ Word' in cmt:
                if re_load.search(cmt):
                    dst_reg = re_load.search(cmt).group(1)
                    pat = f'(lsu) {dst_reg}  <--'
                    searches.append({'pat': pat, 'start': time})
                else:
                    print(f'unsupported load lah: {cmt}')

        # If this line is an acc-only line, get the data
        if not match:
            match = re_acc_line.match(line)
            if match:
                (time, cyc, priv, cmt) = tuple(
                    [match.group(i+1).strip() for i in range(re_acc_line.groups)])

        time = int(time) if use_time else int(cyc)

        # Check for any open searches
        removes = []
        for s in searches:
            if s['pat'] in cmt:
                lah[s['start']] = time
                removes.append(s)
        [searches.remove(r) for r in removes]

    # for l in lah:
    #     print(f'{l} -> {lah[l]}')
    return lah


# Parses a trace file and returns a list of TraceViewer events.
# Each event is formatted as a dictionary.
def parse_trace(filename, **kwargs):

    start = kwargs['start']
    end = kwargs['end']
    fmt = kwargs['fmt']

    # Open trace
    print(f'parsing trace {filename}', file=sys.stderr)
    lah = {}
    buf = []
    fails = lines = 0
    with open(filename) as f:

        # Read lines
        all_lines = f.readlines()
        if end < 0:
            end = len(all_lines) + end + 1
        all_lines = all_lines[start:end]

        # offload lookahead
        if fmt == 'snitch':
            lah = offload_lookahead(all_lines, **kwargs)

        # Use a progress bar iterator if the package is installed
        if has_progressbar:
            iterations = progressbar.progressbar(
                    enumerate(all_lines),
                    max_value=len(all_lines))
        else:
            iterations = enumerate(all_lines)

        # Iterate lines
        events = []
        for lino, line in iterations:
            # Parse line
            parsed_line = parse_line(line, **kwargs)
            if parsed_line:
                buf.append(parsed_line)
            else:
                fails += 1
            lines += 1

            # Flush buffer when it contains enough lines
            if len(buf) > 10:
                events += flush(lah, buf, **kwargs)
        events += flush(lah, buf, **kwargs)

        print(f' parsed {lines-fails} of {lines} lines', file=sys.stderr)
        return events


def parse_traces(traces, **kwargs):

    # Open ELF file
    elf_path = kwargs['elf']
    kwargs['elf'] = Elf(elf_path, a2l_binary=kwargs['addr2line'])

    # Iterate traces
    events = []
    for i, filename in enumerate(traces):

        # Extract hartid from filename or use current index
        # TODO doesn't work with hex numbers
        # parsed_nums = re.findall(r'\d+', filename)
        # hartid = int(parsed_nums[-1]) if len(parsed_nums) else i
        hartid = i

        # Extract TraceViewer events from trace
        trace_events = parse_trace(filename, **kwargs)

        # Assign a per-trace unique TID or PID to all events
        pid = elf_path if 'pid' not in kwargs else kwargs['pid']
        for event in trace_events:
            if kwargs['collapse_call_stack']:
                event['pid'] = pid
                event['tid'] = hartid
            else:
                event['pid'] = pid+':hartid'+str(hartid)

        # Add to events from previous traces
        events += trace_events

    return events


def main(**kwargs):
    elf = kwargs['elf']
    traces = kwargs['traces']
    output = kwargs['output']
    addr2line = kwargs['addr2line']

    print('elf:', elf, file=sys.stderr)
    print('traces:', traces, file=sys.stderr)
    print('output:', output, file=sys.stderr)
    print('addr2line:', addr2line, file=sys.stderr)

    # Parse traces and create TraceViewer JSON object
    events = parse_traces(**kwargs)
    tvobj = {'traceEvents': events, 'displayTimeUnit': 'ns'}

    # Dump JSON object to file
    with open(output, 'w') as output_file:
        json.dump(tvobj, output_file, indent=4)


# Parse command-line args
def parse_args():
    # Argument parsing
    parser = argparse.ArgumentParser('tracevis', allow_abbrev=True)
    parser.add_argument(
        'elf',
        metavar='<elf>',
        help='The binary executed to generate the traces',
    )
    parser.add_argument(
        'traces',
        metavar='<trace>',
        nargs='+',
        help='Traces to visualize')
    parser.add_argument(
        '-o',
        '--output',
        metavar='<json>',
        nargs='?',
        default='chrome.json',
        help='Output JSON file')
    parser.add_argument(
        '--addr2line',
        metavar='<path>',
        nargs='?',
        default='addr2line',
        help='`addr2line` binary to use for parsing')
    parser.add_argument(
        '-t',
        '--time',
        dest='use_time',
        action='store_true',
        help='Use the traces time instead of cycles')
    parser.add_argument(
        '-f',
        '--format',
        dest='fmt',
        type=str,
        default='snitch',
        choices=FORMATS,
        help='Trace format')
    parser.add_argument(
        '--collapse-call-stack',
        action='store_true',
        help='Visualize all instructions of a core in a single TraceViewer thread')
    parser.add_argument(
        '-s',
        '--start',
        metavar='<line>',
        nargs='?',
        type=int,
        default=0,
        help='First line to parse')
    parser.add_argument(
        '-e',
        '--end',
        metavar='<line>',
        nargs='?',
        type=int,
        default=-1,
        help='Last line to parse (inclusive)')
    return parser.parse_args()


if __name__ == '__main__':
    args = vars(parse_args())
    main(**args)
