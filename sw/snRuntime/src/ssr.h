// Copyright 2023 ETH Zurich and University of Bologna.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * @file
 * @brief This file contains functions to conveniently program Snitch's SSRs.
 *
 * An SSR stream can be configured to replace a store (or load) sequence as
 * could be generated by an N-dimensional affine loop nest, e.g. the following
 * store sequence can be mapped to a 2D write SSR:
 * @code{.c}
 * for (int i = 0; i < b1; i++)
 *     for (int j = 0; j < b0; j++)
 *         ptr[i * s1 + j * s0] = 0;
 * @endcode
 *
 * An ISSR (Indirect SSR) stream can be configured to replace a store (or load)
 * sequence as could be generated by:
 * @code{.c}
 * for (int i = 0; i < bound; i++)
 *     base[idcs[i]] = 0;
 * @endcode
 *
 * The convenience functions provided in this file can be used to set up such
 * access patterns. The function argument names reflect the variable names
 * presented in these sample code snippets.
 *
 * Note: The exact number of elements configured in an (I)SSR stream must be
 * consumed. Failure to comply with this requirement will result in undefined
 * behaviour.
 */

#pragma once

/**
 * @brief Synchronize the integer and float pipelines.
 */
inline void snrt_fpu_fence() {
    unsigned tmp;
    asm volatile(
        "fmv.x.w %0, fa0\n"
        "mv      %0, %0\n"
        : "+r"(tmp)::"memory");
}

/**
 * @brief The different SSRs.
 */
typedef enum {
    SNRT_SSR_DM0 = 0,    /**< SSR data mover 0 */
    SNRT_SSR_DM1 = 1,    /**< SSR data mover 1 */
    SNRT_SSR_DM2 = 2,    /**< SSR data mover 2 */
    SNRT_SSR_DM_ALL = 31 /**< Write to all SSRs */
} snrt_ssr_dm_t;

/**
 * @brief The different dimensions.
 */
typedef enum {
    SNRT_SSR_1D = 0, /**< 1D stream */
    SNRT_SSR_2D = 1, /**< 2D stream */
    SNRT_SSR_3D = 2, /**< 3D stream */
    SNRT_SSR_4D = 3  /**< 4D stream */
} snrt_ssr_dim_t;

/**
 * @brief The SSR configuration registers.
 */
typedef enum {
    SNRT_SSR_REG_STATUS = 0,      /**< SSR status register */
    SNRT_SSR_REG_REPEAT = 1,      /**< SSR repeat register */
    SNRT_SSR_REG_BOUNDS = 2,      /**< SSR bounds register */
    SNRT_SSR_REG_STRIDES = 6,     /**< SSR strides register */
    SNRT_SSR_REG_IDX_CFG = 10,    /**< SSSR index configuration register */
    SNRT_SSR_REG_IDX_BASE = 11,   /**< SSSR base address register */
    SNRT_SSR_REG_RPTR_INDIR = 16, /**< SSSR indir. indices read ptr register */
    SNRT_SSR_REG_RPTR = 24,       /**< SSR read pointer register */
    SNRT_SSR_REG_WPTR = 28        /**< SSR write pointer register */
} snrt_ssr_reg_t;

/**
 * @brief The size of the SSSR indirection indices.
 */
typedef enum {
    SNRT_SSR_IDXSIZE_U8 = 0,  /**< Unsigned 8-bit integer */
    SNRT_SSR_IDXSIZE_U16 = 1, /**< Unsigned 16-bit integer */
    SNRT_SSR_IDXSIZE_U32 = 2, /**< Unsigned 32-bit integer */
    SNRT_SSR_IDXSIZE_U64 = 3, /**< Unsigned 64-bit integer */
} snrt_ssr_idxsize_t;

/**
 * @brief Enable all SSRs.
 */
inline void snrt_ssr_enable() {
#ifdef __TOOLCHAIN_LLVM__
    __builtin_ssr_enable();
#else
    asm volatile("csrsi 0x7C0, 1\n");
#endif
}

/**
 * @brief Disable all SSRs.
 */
inline void snrt_ssr_disable() {
#ifdef __TOOLCHAIN_LLVM__
    __builtin_ssr_disable();
#else
    asm volatile("csrci 0x7C0, 1\n");
#endif
}

/**
 * @brief Enable scalar chaining.
 * @param mask A bitmask indicating which registers should be enabled for
 *             chaining.
 */
inline void snrt_sc_enable(uint32_t mask) {
    asm volatile("csrs 0x7C3, %[mask]\n" : : [ mask ] "r"(mask) :);
}

/**
 * @brief Disable scalar chaining.
 */
inline void snrt_sc_disable(uint32_t mask) {
    asm volatile("csrc 0x7C3, %[mask]\n" : : [ mask ] "r"(mask) :);
}

/**
 * @brief Read the value of an SSR configuration register.
 * @param reg The register index.
 * @param dm The SSR index.
 * @return The value of the register.
 */
static inline uint32_t read_ssr_cfg(const snrt_ssr_reg_t reg,
                                    const snrt_ssr_dm_t dm) {
    uint32_t value;
    asm volatile("scfgri %[value], %[dm] | %[reg]<<5\n"
                 : [ value ] "=r"(value)
                 : [ dm ] "i"(dm), [ reg ] "i"(reg));
    return value;
}

/**
 * @brief Write a value to an SSR configuration register.
 * @param reg The register index.
 * @param dm The SSR index.
 * @param value The value to write.
 * @note The function passes the `reg` and `dm` arguments as an immediate,
 *       thus these must be known at compile time. As a consequence, the
 *       function must use internal linkage (`static` keyword) and must be
 *       always inlined. This is true also for all functions invoking this
 *       function, and passing down their own arguments to `reg` or `dm`.
 */
static inline void write_ssr_cfg(const snrt_ssr_reg_t reg,
                                 const snrt_ssr_dm_t dm, uint32_t value) {
    asm volatile("scfgwi %[value], %[dm] | %[reg]<<5\n" ::[value] "r"(value),
                 [ dm ] "i"(dm), [ reg ] "i"(reg));
}

/**
 * @brief Configure an SSR data mover for a 1D loop nest.
 * @param dm The SSR index.
 * @param b0 The bound of the loop.
 * @param s0 The stride of the loop.
 */
static inline void snrt_ssr_loop_1d(const snrt_ssr_dm_t dm, size_t b0,
                                    size_t s0) {
    --b0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 0), dm, b0);
    size_t a = 0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 0), dm, s0 - a);
    a += s0 * b0;
}

/**
 * @brief Configure an SSR data mover for a 2D loop nest.
 * @param dm The SSR index.
 * @param b0 The bound of the first loop.
 * @param b1 The bound of the second loop.
 * @param s0 The stride of the first loop.
 * @param s1 The stride of the second loop.
 */
static inline void snrt_ssr_loop_2d(const snrt_ssr_dm_t dm, size_t b0,
                                    size_t b1, size_t s0, size_t s1) {
    --b0;
    --b1;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 0), dm, b0);
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 1), dm, b1);
    size_t a = 0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 0), dm, s0 - a);
    a += s0 * b0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 1), dm, s1 - a);
    a += s1 * b1;
}

/**
 * @brief Configure an SSR data mover for a 3D loop nest.
 * @param dm The SSR index.
 * @param b0 The bound of the first loop.
 * @param b1 The bound of the second loop.
 * @param b2 The bound of the third loop.
 * @param s0 The stride of the first loop.
 * @param s1 The stride of the second loop.
 * @param s2 The stride of the third loop.
 */
static inline void snrt_ssr_loop_3d(const snrt_ssr_dm_t dm, size_t b0,
                                    size_t b1, size_t b2, size_t s0, size_t s1,
                                    size_t s2) {
    --b0;
    --b1;
    --b2;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 0), dm, b0);
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 1), dm, b1);
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 2), dm, b2);
    size_t a = 0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 0), dm, s0 - a);
    a += s0 * b0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 1), dm, s1 - a);
    a += s1 * b1;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 2), dm, s2 - a);
    a += s2 * b2;
}

/**
 * @brief Configure an SSR data mover for a 4D loop nest.
 * @param dm The SSR index.
 * @param b0 The bound of the first loop.
 * @param b1 The bound of the second loop.
 * @param b2 The bound of the third loop.
 * @param b3 The bound of the fourth loop.
 * @param s0 The stride of the first loop.
 * @param s1 The stride of the second loop.
 * @param s2 The stride of the third loop.
 * @param s3 The stride of the fourth loop.
 */
static inline void snrt_ssr_loop_4d(const snrt_ssr_dm_t dm, size_t b0,
                                    size_t b1, size_t b2, size_t b3, size_t s0,
                                    size_t s1, size_t s2, size_t s3) {
    --b0;
    --b1;
    --b2;
    --b3;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 0), dm, b0);
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 1), dm, b1);
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 2), dm, b2);
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_BOUNDS + 3), dm, b3);
    size_t a = 0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 0), dm, s0 - a);
    a += s0 * b0;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 1), dm, s1 - a);
    a += s1 * b1;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 2), dm, s2 - a);
    a += s2 * b2;
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_STRIDES + 3), dm, s3 - a);
    a += s3 * b3;
}

/**
 * @brief Configure the repetition count for a stream.
 * @param dm The SSR index.
 * @param count The repetition count.
 */
static inline void snrt_ssr_repeat(const snrt_ssr_dm_t dm, size_t count) {
    write_ssr_cfg(SNRT_SSR_REG_REPEAT, dm, count - 1);
}

/**
 * @brief Start a streaming read.
 * @param dm The SSR index.
 * @param dim The number of dimensions to use.
 * @param ptr The pointer to the data.
 */
static inline void snrt_ssr_read(const snrt_ssr_dm_t dm,
                                 const snrt_ssr_dim_t dim, volatile void *ptr) {
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_RPTR + dim), dm,
                  (uintptr_t)ptr);
}

/**
 * @brief Start a streaming write.
 * @param dm The SSR index.
 * @param dim The number of dimensions to use.
 * @param ptr The pointer to the data.
 */
static inline void snrt_ssr_write(const snrt_ssr_dm_t dm,
                                  const snrt_ssr_dim_t dim,
                                  volatile void *ptr) {
    write_ssr_cfg((snrt_ssr_reg_t)(SNRT_SSR_REG_WPTR + dim), dm,
                  (uintptr_t)ptr);
}

/**
 * @brief Start a streaming indirect read.
 * @param dm The SSSR index.
 * @param base The base pointer to the data.
 * @param ptr The pointer to the indirection indices.
 * @param bound The bound of the first (and only) loop.
 * @param idxsize The size of the indices.
 */
static inline void snrt_issr_set_idx_cfg(const snrt_ssr_dm_t dm,
                                         snrt_ssr_idxsize_t idxsize) {
    write_ssr_cfg(SNRT_SSR_REG_IDX_CFG, dm, (idxsize & 0xFF));
}

static inline void snrt_issr_set_bound(const snrt_ssr_dm_t dm, size_t bound) {
    write_ssr_cfg(SNRT_SSR_REG_BOUNDS, dm, --bound);
}

static inline void snrt_issr_set_ptrs(const snrt_ssr_dm_t dm,
                                      volatile void *base,
                                      volatile void *idcs) {
    write_ssr_cfg(SNRT_SSR_REG_IDX_BASE, dm, (uintptr_t)base);
    write_ssr_cfg(SNRT_SSR_REG_RPTR_INDIR, dm, (uintptr_t)idcs);
}

static inline void snrt_issr_read(const snrt_ssr_dm_t dm, volatile void *base,
                                  volatile void *idcs, size_t bound,
                                  snrt_ssr_idxsize_t idxsize) {
    snrt_issr_set_idx_cfg(dm, idxsize);
    snrt_issr_set_bound(dm, bound);
    snrt_issr_set_ptrs(dm, base, idcs);
}