// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51

/// # Snitch-wide Constants.
/// Fixed constants for a Snitch system.

// AUTOMATICALLY GENERATED by gen_snitch_pkg.py; edit the script instead.

package snitch_pma_pkg;

  localparam NrMaxRules = 1;

  typedef struct packed {
      logic [47:0] base; // base which needs to match
      logic [47:0] mask; // bit mask which bits to consider when matching the rule
  } rule_t;

  typedef struct packed {
    // PMAs
    // Non-idempotent regions
    int unsigned            NrNonIdempotentRegionRules; // Number of non-idempotent rules
    rule_t [NrMaxRules-1:0] NonIdempotentRegion;
    // Execute Regions
    int unsigned            NrExecuteRegionRules; // Number of regions which have execute property
    rule_t [NrMaxRules-1:0] ExecuteRegion;
    // Cached Regions
    int unsigned            NrCachedRegionRules; // Number of regions which have cached property
    rule_t [NrMaxRules-1:0] CachedRegion;
    // Atomicity Regions
    int unsigned            NrAMORegionRules; // Number of regions which have Atomic property
    rule_t [NrMaxRules-1:0] AMORegion;
  } snitch_pma_t;

  // Public interface
  function automatic logic range_check(logic[47:0] base, logic[47:0] mask, logic[47:0] address);
    return (address & mask) == (base & mask);
  endfunction : range_check

  function automatic logic is_inside_nonidempotent_regions (snitch_pma_t cfg, logic[47:0] address);
    logic [NrMaxRules-1:0] pass;
    pass = '0;
    for (int unsigned k = 0; k < cfg.NrNonIdempotentRegionRules; k++) begin
      pass[k] = range_check(cfg.NonIdempotentRegion[k].base, cfg.NonIdempotentRegion[k].mask, address);
    end
    return |pass;
  endfunction : is_inside_nonidempotent_regions

  function automatic logic is_inside_execute_regions (snitch_pma_t cfg, logic[47:0] address);
    // if we don't specify any region we assume everything is accessible
    logic [NrMaxRules-1:0] pass;
    pass = '0;
    for (int unsigned k = 0; k < cfg.NrExecuteRegionRules; k++) begin
      pass[k] = range_check(cfg.ExecuteRegion[k].base, cfg.ExecuteRegion[k].mask, address);
    end
    return |pass;
  endfunction : is_inside_execute_regions

  function automatic logic is_inside_cacheable_regions (snitch_pma_t cfg, logic[47:0] address);
    automatic logic [NrMaxRules-1:0] pass;
    pass = '0;
    for (int unsigned k = 0; k < cfg.NrCachedRegionRules; k++) begin
      pass[k] = range_check(cfg.CachedRegion[k].base, cfg.CachedRegion[k].mask, address);
    end
    return |pass;
  endfunction : is_inside_cacheable_regions
endpackage

package snitch_pkg;

  localparam DLEN = 64;

  // Physical address width of the system.
  localparam PLEN = 48;

  typedef logic [PLEN-1:0] addr_t;
  // Data width of the system.
  typedef logic [DLEN-1:0] data_t;
  typedef logic [DLEN/8-1:0] strb_t;
  typedef logic [1:0] size_t;

  // Bytes needed to produce aligned data.
  localparam DATA_ALIGN = $clog2(DLEN/8);

  localparam dm::hartinfo_t SnitchHartinfo = '{
    zero1: '0,
    nscratch: 1,
    zero0: '0,
    dataaccess: 1,
    datasize: dm::DataCount,
    dataaddr: dm::DataAddr
  };

  typedef enum logic [3:0] {
      AMONone = 4'h0,
      AMOSwap = 4'h1,
      AMOAdd  = 4'h2,
      AMOAnd  = 4'h3,
      AMOOr   = 4'h4,
      AMOXor  = 4'h5,
      AMOMax  = 4'h6,
      AMOMaxu = 4'h7,
      AMOMin  = 4'h8,
      AMOMinu = 4'h9,
      AMOLR   = 4'hA,
      AMOSC   = 4'hB
  } amo_op_t;

  typedef struct packed {
    addr_t      addr;
    amo_op_t    amo;
    logic       write;
    data_t      data;
    logic [1:0] size;
    strb_t      strb;
  } dreq_t;

  typedef struct packed {
    data_t data;
    logic  error;
  } dresp_t;

  typedef enum logic [31:0] {
    FP_SS = 0,
    SHARED_MULDIV = 1,
    DMA_SS = 2,
    INT_SS = 3
  } acc_addr_e;

  typedef struct packed {
    acc_addr_e   addr;
    logic [4:0]  id;
    logic [31:0] data_op;
    data_t       data_arga;
    data_t       data_argb;
    addr_t       data_argc;
  } acc_req_t;

  typedef struct packed {
    logic [4:0] id;
    logic       error;
    data_t      data;
  } acc_resp_t;

  typedef enum logic [1:0] {
    PrivLvlM = 2'b11,
    PrivLvlS = 2'b01,
    PrivLvlU = 2'b00
  } priv_lvl_t;

  // Extension state.
  typedef enum logic [1:0] {
    XOff = 2'b00,
    XInitial = 2'b01,
    XClean = 2'b10,
    XDirty = 2'b11
  } x_state_e;

  typedef struct packed {
    logic         sd;     // signal dirty - read-only - hardwired zero
    logic [7:0]   wpri3;  // writes preserved reads ignored
    logic         tsr;    // trap sret
    logic         tw;     // time wait
    logic         tvm;    // trap virtual memory
    logic         mxr;    // make executable readable
    logic         sum;    // permit supervisor user memory access
    logic         mprv;   // modify privilege - privilege level for ld/st
    x_state_e     xs;     // extension register - hardwired to zero
    x_state_e     fs;     // extension register - hardwired to zero for non FP and to Dirty for FP.
    priv_lvl_t    mpp;    // holds the previous privilege mode up to machine
    logic [1:0]   wpri2;  // writes preserved reads ignored
    logic         spp;    // holds the previous privilege mode up to supervisor
    logic         mpie;   // machine interrupts enable bit active prior to trap
    logic         wpri1;  // writes preserved reads ignored
    logic         spie;   // supervisor interrupts enable bit active prior to trap
    logic         upie;   // user interrupts enable bit active prior to trap - hardwired to zero
    logic         mie;    // machine interrupts enable
    logic         wpri0;  // writes preserved reads ignored
    logic         sie;    // supervisor interrupts enable
    logic         uie;    // user interrupts enable - hardwired to zero
  } status_rv32_t;

  localparam int unsigned PAGE_SHIFT = 14;
  /// Total physical address portion.
  localparam int unsigned PPN_SIZE = 34;
  /// Size in bits of the virtual address segments
  localparam int unsigned VPN_SIZE = 9;
  /// Page Table Entry Size in Bytes
  localparam int unsigned PTE_SIZE = 8;

  /// Virtual Address Definition
  typedef struct packed {
    /// Virtual Page Number 1
    logic [31:23] vpn1;
    /// Virtual Page Number 0
    logic [22:14] vpn0;
  } va_t;

  /// Physical Address Definition
  typedef struct packed {
    /// Physical Page Number 1
    logic [47:24] ppn1;
    /// Physical Page Number 0
    logic [23:14] ppn0;
  } pa_t;

  typedef struct packed {
    logic               d;
    logic               a;
    logic               u;
    logic               x;
    logic               w;
    logic               r;
  } pte_flags_t;

  // Page table entries
  typedef struct packed {
    pa_t                pa;
    pte_flags_t         flags;
  } l0_pte_t;

  /// (Semi-)custom PTE
  typedef struct packed {
    pa_t                pa;
    logic [9:8]         rsw;
    logic               d;
    logic               a;
    logic               g;
    logic               u;
    logic               x;
    logic               w;
    logic               r;
    logic               v;
  } pte_sv32_t;

  localparam logic [3:0] INSTR_ADDR_MISALIGNED = 0;
  localparam logic [3:0] INSTR_ACCESS_FAULT    = 1;
  localparam logic [3:0] ILLEGAL_INSTR         = 2;
  localparam logic [3:0] BREAKPOINT            = 3;
  localparam logic [3:0] LD_ADDR_MISALIGNED    = 4;
  localparam logic [3:0] LD_ACCESS_FAULT       = 5;
  localparam logic [3:0] ST_ADDR_MISALIGNED    = 6;
  localparam logic [3:0] ST_ACCESS_FAULT       = 7;
  localparam logic [3:0] ENV_CALL_UMODE        = 8;  // environment call from user mode
  localparam logic [3:0] ENV_CALL_SMODE        = 9;  // environment call from supervisor mode
  localparam logic [3:0] ENV_CALL_MMODE        = 11; // environment call from machine mode
  localparam logic [3:0] INSTR_PAGE_FAULT      = 12; // Instruction page fault
  localparam logic [3:0] LOAD_PAGE_FAULT       = 13; // Load page fault
  localparam logic [3:0] STORE_PAGE_FAULT      = 15; // Store page fault

  localparam logic [3:0] MSI = 3;
  localparam logic [3:0] MTI = 7;
  localparam logic [3:0] MEI = 11;
  localparam logic [3:0] SSI = 1;
  localparam logic [3:0] STI = 5;
  localparam logic [3:0] SEI = 9;

  // Registers which are used as SSRs
  localparam [4:0] FT0 = 5'd0;
  localparam [4:0] FT1 = 5'd1;
  localparam [4:0] FT2 = 5'd2;
  localparam [1:0][4:0] SSRRegs = {FT2, FT1, FT0};
  function automatic logic is_ssr(logic [4:0] register);
    unique case (register)
      FT0, FT1, FT2: return 1'b1;
      default : return 0;
    endcase
  endfunction

  // FPU
  // Floating-point extensions configuration
  localparam bit RVF = 1; // Is F extension enabled - MUST BE 1 IF D ENABLED!
  localparam bit RVD = 1; // Is D extension enabled

  // Transprecision floating-point extensions configuration
  localparam bit XF16    = 0; // Is half-precision float extension (Xf16) enabled
  localparam bit XF16ALT = 0; // Is alt. half-precision float extension (Xf16alt) enabled
  localparam bit XF8     = 0; // Is quarter-precision float extension (Xf8) enabled
  localparam bit XFVEC   = 1; // Is vectorial float SIMD extension (Xfvec) enabled
  // Non-standard extension present
  localparam bit NSX = XF16 | XF16ALT | XF8 | XFVEC;
  // ------------------
  // FPU Configuration
  // ------------------
  localparam bit FP_PRESENT = RVF | RVD | XF16 | XF16ALT | XF8;

  localparam FLEN = RVD     ? 64 : // D ext.
                    RVF     ? 32 : // F ext.
                    XF16    ? 16 : // Xf16 ext.
                    XF16ALT ? 16 : // Xf16alt ext.
                    XF8     ? 8 :  // Xf8 ext.
                    0;             // Unused in case of no FP

  localparam fpnew_pkg::fpu_features_t FPU_FEATURES = '{
    Width:         fpnew_pkg::maximum(FLEN, 32),
    EnableVectors: XFVEC,
    EnableNanBox:  1'b1,
    FpFmtMask:     {RVF, RVD, XF16, XF8, XF16ALT},
    IntFmtMask:    {XFVEC && XF8, XFVEC && (XF16 || XF16ALT), 1'b1, 1'b0}
  };

  // Slaves on Cluster AXI Bus
  typedef enum integer {
    TCDM               = 0,
    ClusterPeripherals = 1,
    SoC                = 2
  } cluster_slave_e;

  typedef enum integer {
    CoreReq = 0,
    ICache  = 1,
    AXISoC  = 2,
    PTW     = 3
  } cluster_master_e;

  // Slaves on Cluster DMA AXI Bus
  typedef enum int unsigned {
    TCDMDMA  = 32'd0,
    SoCDMA   = 32'd1
  } cluster_slave_dma_e;

  typedef enum int unsigned {
    SDMAMst  = 32'd0
  } cluster_master_dma_e;

  localparam int unsigned NrSlaves = 3;
  localparam int unsigned NrMasters = 4;

  localparam int IdWidth = 2;
  localparam int IdWidthSlave = $clog2(NrMasters) + IdWidth;

  // DMA X-BAR configuration
  localparam int unsigned NrDmaSlaves = 2;
  localparam int unsigned NrDmaMasters = 1;
  localparam int IdWidthDma = 6;
  localparam int IdWidthDmaSlave = $clog2(NrDmaMasters) + IdWidthDma;

  // Cluster Peripheral Registers
  typedef enum logic [16:0] {
    TCDMStartAddressReg = 17'h0_0000,
    TCDMEndAddressReg   = 17'h0_0008,
    NrCoresReg          = 17'h0_0010,
    FetchEnableReg      = 17'h0_0018,
    ScratchReg          = 17'h0_0020,
    WakeUpReg           = 17'h0_0028,
    CycleCountReg       = 17'h0_0030,
    BarrierReg          = 17'h0_0038,
    ClusterIdReg        = 17'h0_0040,
    TcdmAccessedReg     = 17'h0_FFF0,
    TcdmCongestedReg    = 17'h0_FFF8,
    PerfCounterBase     = 17'h1_0000
  } cluster_peripheral_addr_e;

  // Event strobes per core, counted by the performance counters in the cluster
  // peripherals.
  typedef struct packed {
    logic issue_fpu;          // core operations performed in the FPU
    logic issue_fpu_seq;      // includes load/store operations
    logic issue_core_to_fpu;  // instructions issued from core to FPU
  } core_events_t;

  // Trace-Port Definitions
  typedef struct packed {
    longint acc_q_hs;
    longint fpu_out_hs;
    longint lsu_q_hs;
    longint op_in;
    longint rs1;
    longint rs2;
    longint rs3;
    longint rd;
    longint op_sel_0;
    longint op_sel_1;
    longint op_sel_2;
    longint src_fmt;
    longint dst_fmt;
    longint int_fmt;
    longint acc_qdata_0;
    longint acc_qdata_1;
    longint acc_qdata_2;
    longint op_0;
    longint op_1;
    longint op_2;
    longint use_fpu;
    longint fpu_in_rd;
    longint fpu_in_acc;
    longint ls_size;
    longint is_load;
    longint is_store;
    longint lsu_qaddr;
    longint lsu_rd;
    longint acc_wb_ready;
    longint fpu_out_acc;
    longint fpr_waddr;
    longint fpr_wdata;
    longint fpr_we;
  } fpu_trace_port_t;

  typedef struct packed {
    longint cbuf_push;
    longint is_outer;
    longint max_inst;
    longint max_rpt;
    longint stg_max;
    longint stg_mask;
  } fpu_sequencer_trace_port_t;

  localparam int NumFPOutstandingLoads = 4;
  localparam int NumIntOutstandingLoads = 1;
  // Number of instructions the sequencer can hold
  localparam int FPUSequencerInstr = 16;
  localparam int IPUSequencerInstr = 16;

  // SSRs
  localparam snitch_pkg::addr_t SSR_ADDR_BASE = 'h20_4800;
  localparam snitch_pkg::addr_t SSR_ADDR_MASK = 'hffff_fe00;
  localparam logic [11:0] CSR_SSR = 'h7c0;
  localparam int SSRNrCredits = 4;
  localparam logic [11:0] CSR_MSEG = 12'hBC0;

  localparam int unsigned NumDTLBEntries = 1;
  localparam int unsigned NumITLBEntries = 1;

  // ------------------
  // FPU Configuration
  // ------------------

  // Latencies of FP ops (number of regs)
  localparam int unsigned LAT_COMP_FP32    = 'd3;
  localparam int unsigned LAT_COMP_FP64    = 'd3;
  localparam int unsigned LAT_COMP_FP16    = 'd2;
  localparam int unsigned LAT_COMP_FP16ALT = 'd2;
  localparam int unsigned LAT_COMP_FP8     = 'd1;
  localparam int unsigned LAT_DIVSQRT      = 'd1;
  localparam int unsigned LAT_NONCOMP      = 'd1;
  localparam int unsigned LAT_CONV         = 'd1;

  localparam fpnew_pkg::fpu_implementation_t FPU_IMPLEMENTATION = '{
    PipeRegs:  '{// FP32, FP64, FP16, FP8, FP16alt
                 '{LAT_COMP_FP32, LAT_COMP_FP64, LAT_COMP_FP16, LAT_COMP_FP8, LAT_COMP_FP16ALT}, // ADDMUL
                 '{default: LAT_DIVSQRT}, // DIVSQRT
                 '{default: LAT_NONCOMP}, // NONCOMP
                 '{default: LAT_CONV}},   // CONV
    UnitTypes: '{'{default: fpnew_pkg::MERGED},
                 // '{fpnew_pkg::PARALLEL, fpnew_pkg::PARALLEL, fpnew_pkg::MERGED, fpnew_pkg::MERGED, fpnew_pkg::MERGED}, // ADDMUL
                 '{default: fpnew_pkg::DISABLED}, // DIVSQRT
                 '{default: fpnew_pkg::PARALLEL}, // NONCOMP
                 '{default: fpnew_pkg::MERGED}},  // CONV
    PipeConfig: fpnew_pkg::BEFORE
  };

  // Amount of address bit which should be used for accesses from the SoC side.
  // This effectively determines the Address Space of a Snitch Cluster.
  localparam SoCRequestAddrBits = 32;

  // Address Map
  // TCDM, everything below 0x4000_0000
  localparam addr_t TCDMStartAddress = 'h0;
  localparam addr_t TCDMMask         = '1 << 28;

  localparam addr_t ClusterPeriphStartAddress = 'h40000000;

  localparam int unsigned NrRules = NrSlaves - 1;

  typedef struct packed {
    int unsigned idx;
    addr_t start_addr;
    addr_t end_addr;
  } xbar_rule_t;

  localparam axi_pkg::xbar_cfg_t CLUSTER_XBAR_CFG = '{
    NoSlvPorts: NrMasters,
    NoMstPorts: NrSlaves,
    MaxMstTrans: 4,
    MaxSlvTrans: 4,
    FallThrough: 1'b0,
    LatencyMode: axi_pkg::CUT_ALL_PORTS,
    AxiIdWidthSlvPorts: IdWidth,
    AxiIdUsedSlvPorts: IdWidth,
    AxiAddrWidth: 48,
    AxiDataWidth: 64,
    NoAddrRules: NrRules
  };

  localparam xbar_rule_t [NrRules-1:0] CLUSTER_XBAR_RULES = '{
    '{
      idx:        TCDM,
      start_addr: TCDMStartAddress,
      end_addr:   TCDMStartAddress + (1 << 28)
    },
    '{
      idx:        ClusterPeripherals,
      start_addr: ClusterPeriphStartAddress,
      end_addr:   ClusterPeriphStartAddress + (1 << $bits(cluster_peripheral_addr_e))
    }
  };

  // DMA configuration struct
  localparam axi_pkg::xbar_cfg_t DMA_XBAR_CFG = '{
    NoSlvPorts:          NrDmaMasters,
    NoMstPorts:          NrDmaSlaves,
    MaxMstTrans:         4,
    MaxSlvTrans:         4,
    FallThrough:         1'b0,
    LatencyMode:         axi_pkg::CUT_ALL_PORTS,
    AxiIdWidthSlvPorts:  IdWidthDma,
    AxiIdUsedSlvPorts:   IdWidthDma,
    AxiAddrWidth:        48,
    AxiDataWidth:        512,
    NoAddrRules:         1
  };

  localparam xbar_rule_t [DMA_XBAR_CFG.NoAddrRules-1:0] DMA_XBAR_RULE = '{
    '{
      idx:        TCDMDMA,
      start_addr: TCDMStartAddress,
      end_addr:   TCDMStartAddress + (1 << 28)
    }
  };


  localparam snitch_pma_pkg::snitch_pma_t SnitchPMACfg = '{
    NrNonIdempotentRegionRules: 0,
    NonIdempotentRegion: '{

      '{base: 48'h0, mask: 48'h0}

    },
    NrExecuteRegionRules: 0,
    ExecuteRegion: '{

      '{base: 48'h0, mask: 48'h0}

    },
    NrCachedRegionRules: 1,
    CachedRegion: '{

        '{base: 48'h80000000, mask: 48'h80000000}

    },
    NrAMORegionRules: 0,
    AMORegion: '{

      '{base: 48'h0, mask: 48'h0}

    }
  };

  localparam int unsigned DMA_AXI_REQ_FIFO_DEPTH = 3;
  localparam int unsigned DMA_REQ_FIFO_DEPTH = 3;

endpackage

`include "axi/typedef.svh"

package snitch_axi_pkg;

    localparam UserWidth = 1;
    localparam AddrWidth = 48;
    localparam DataWidth = 64;
    localparam StrbWidth = 8;

    typedef logic [snitch_pkg::IdWidth-1:0]      id_t;
    typedef logic [snitch_pkg::IdWidthSlave-1:0] id_slv_t;
    typedef logic [AddrWidth-1:0] addr_t;
    typedef logic [DataWidth-1:0] data_t;
    typedef logic [StrbWidth-1:0] strb_t;
    typedef logic [UserWidth-1:0] user_t;

    // DMA interface
    localparam DMAUserWidth = 1;
    localparam DMAAddrWidth = 48;
    localparam DMADataWidth = 512;
    localparam DMAStrbWidth = 64;

    typedef logic [snitch_pkg::IdWidthDma-1:0]       id_dma_t;
    typedef logic [snitch_pkg::IdWidthDmaSlave-1:0]  id_dma_slv_t;
    typedef logic [DMAAddrWidth-1:0] addr_dma_t;
    typedef logic [DMADataWidth-1:0] data_dma_t;
    typedef logic [DMAStrbWidth-1:0] strb_dma_t;
    typedef logic [DMAUserWidth-1:0] user_dma_t;

    `AXI_TYPEDEF_AW_CHAN_T(aw_chan_t, addr_t, id_t, user_t)
    `AXI_TYPEDEF_AW_CHAN_T(aw_chan_slv_t, addr_t, id_slv_t, user_t)
    `AXI_TYPEDEF_AW_CHAN_T(aw_chan_dma_t, addr_dma_t, id_dma_t, user_t)
    `AXI_TYPEDEF_AW_CHAN_T(aw_chan_dma_slv_t, addr_dma_t, id_dma_slv_t, user_t)

    `AXI_TYPEDEF_W_CHAN_T(w_chan_t, data_t, strb_t, user_t)
    `AXI_TYPEDEF_W_CHAN_T(w_chan_dma_t, data_dma_t, strb_dma_t, user_t)

    `AXI_TYPEDEF_B_CHAN_T(b_chan_t, id_t, user_t)
    `AXI_TYPEDEF_B_CHAN_T(b_chan_slv_t, id_slv_t, user_t)
    `AXI_TYPEDEF_B_CHAN_T(b_chan_dma_t, id_dma_t, user_t)
    `AXI_TYPEDEF_B_CHAN_T(b_chan_dma_slv_t, id_dma_slv_t, user_t)

    `AXI_TYPEDEF_AR_CHAN_T(ar_chan_t, addr_t, id_t, user_t)
    `AXI_TYPEDEF_AR_CHAN_T(ar_chan_slv_t, addr_t, id_slv_t, user_t)
    `AXI_TYPEDEF_AR_CHAN_T(ar_chan_dma_t, addr_dma_t, id_dma_t, user_t)
    `AXI_TYPEDEF_AR_CHAN_T(ar_chan_dma_slv_t, addr_dma_t, id_dma_slv_t, user_t)

    `AXI_TYPEDEF_R_CHAN_T(r_chan_t, data_t, id_t, user_t)
    `AXI_TYPEDEF_R_CHAN_T(r_chan_slv_t, data_t, id_slv_t, user_t)
    `AXI_TYPEDEF_R_CHAN_T(r_chan_dma_t, data_dma_t, id_dma_t, user_t)
    `AXI_TYPEDEF_R_CHAN_T(r_chan_dma_slv_t, data_dma_t, id_dma_slv_t, user_t)

    `AXI_TYPEDEF_REQ_T(req_t, aw_chan_t, w_chan_t, ar_chan_t)
    `AXI_TYPEDEF_RESP_T(resp_t, b_chan_t, r_chan_t)

    `AXI_TYPEDEF_REQ_T(req_slv_t, aw_chan_slv_t, w_chan_t, ar_chan_slv_t)
    `AXI_TYPEDEF_RESP_T(resp_slv_t, b_chan_slv_t, r_chan_slv_t)

    `AXI_TYPEDEF_REQ_T(req_dma_t, aw_chan_dma_t, w_chan_dma_t, ar_chan_dma_t)
    `AXI_TYPEDEF_RESP_T(resp_dma_t, b_chan_dma_t, r_chan_dma_t)

    `AXI_TYPEDEF_REQ_T(req_dma_slv_t, aw_chan_dma_slv_t, w_chan_dma_t, ar_chan_dma_slv_t)
    `AXI_TYPEDEF_RESP_T(resp_dma_slv_t, b_chan_dma_slv_t, r_chan_dma_slv_t)

endpackage
