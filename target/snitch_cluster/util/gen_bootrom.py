#!/usr/bin/env python3
# Copyright 2024 ETH Zurich and University of Bologna.
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
#
# Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
# Florian Zaruba <zarubaf@iis.ee.ethz.ch>
# Stefan Mach <smach@iis.ee.ethz.ch>
# Thomas Benz <tbenz@iis.ee.ethz.ch>
# Paul Scheffler <paulsc@iis.ee.ethz.ch>
# Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
# Gianna Paulin <pauling@iis.ee.ethz.ch>
# Tim Fischer <fischeti@iis.ee.ethz.ch>

import os
import argparse
import struct

# Parse arguments.
parser = argparse.ArgumentParser(description="Generate bootrom.sv")
parser.add_argument("BINARY", help="Binary image for which to create a bootrom")
parser.add_argument(
    "--sv-module",
    "-m",
    metavar="BINARY",
    help="Name of the combinatorial SystemVerilog bootrom module",
)
args = parser.parse_args()

# Read the bootrom binary.
with open(args.BINARY, "rb") as file:
    binary = file.read()


def format_binary(binary):
    num_words = len(binary) // 4
    sv_code = ""
    for i in range(num_words):
        # Extract each 32-bit word as little-endian and unpack it as an unsigned integer
        word = struct.unpack_from("<I", binary, 4 * i)[0]
        sv_code += f"        bootrom[{i}] = 32'h{word:08x}; /* 0x{4*i:04x} */\n"
    return sv_code[:-1]


if args.sv_module:
    # Emit the code.
    print(
        """
// Copyright 2024 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// AUTOMATICALLY GENERATED by {script}; edit the script instead.

module {module_name} #(
    parameter int unsigned AddrWidth = 32,
    parameter int unsigned DataWidth = 32,
    parameter int unsigned BootromSize = 65536
)(
    input  logic                 clk_i,
    input  logic                 rst_ni,
    input  logic [AddrWidth-1:0] addr_i,
    output logic [DataWidth-1:0] data_o
);

    // The bootrom is stored as 32-bit instruction words.
    // However, the data bus can have a different width.
    logic [BootromSize/4-1:0][31:0] bootrom;
    logic [BootromSize/DataWidth*8-1:0][DataWidth-1:0] bootrom_aligned;

    assign bootrom_aligned = bootrom;
    assign data_o = bootrom_aligned[addr_i[$clog2(BootromSize)-1:$clog2(DataWidth/8)]];

    always_comb begin : gen_bootrom
        bootrom = '0;
{words}
    end

endmodule
    """.strip().format(
            script=os.path.basename(__file__),
            module_name=args.sv_module,
            words=format_binary(binary),
        )
    )
