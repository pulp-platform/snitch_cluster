#!/usr/bin/env python3
#
# Copyright 2020 ETH Zurich
# SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
#
# Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
# Florian Zaruba <zarubaf@iis.ee.ethz.ch>
# Stefan Mach <smach@iis.ee.ethz.ch>
# Thomas Benz <tbenz@iis.ee.ethz.ch>
# Paul Scheffler <paulsc@iis.ee.ethz.ch>
# Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
# Gianna Paulin <pauling@iis.ee.ethz.ch>
# Tim Fischer <fischeti@iis.ee.ethz.ch>

import os
import argparse

from struct import *

# Parse arguments.
parser = argparse.ArgumentParser(description="Generate thestral_bootrom.sv")
parser.add_argument("BINARY",
                    help="Binary image for which to create a bootrom")
parser.add_argument(
    "--sv-module",
    "-m",
    metavar="BINARY",
    help=
    "Combinatorial SystemVerilog module with `reg_interface`. Name of the SystemVerilog module"
)
# Parse arguments.
parser.add_argument(
    "-p",
    "--pad",
    action="store",
    default=0,
    type=int,
    help=
    "Pad to next power of two (if the value is not a power of two it is rounded appropriately)"
)
parser.add_argument("--arm-rom",
                    action="store_true",
                    help="Generate am Arm ROM code file.")
args = parser.parse_args()

# Read the bootrom binary.
with open(args.BINARY, "rb") as file:
    binary = file.read()

# Calculate length of bootrom.
# Fill up the binary with zeroes to the next power of two.
length = 8
while length < max(len(binary), args.pad):
    length *= 2

binary += b"\0" * (length - len(binary))

unpack('>h', binary)

# # Generate the bytes to be emitted.
# def chunks(seq, size):
#     return (seq[pos:pos + size] for pos in range(0, len(seq), size))


# def format_word_bin(word):
#     hex = ["{:08b}".format(int(x)) for x in word]
#     return "".join(reversed(hex))


# def format_word_hex(word):
#     hex = ["{:02x}".format(int(x)) for x in word]
#     hex += ["00"] * (4 - len(word))
#     return "".join(reversed(hex))


# def format_arm_rom(binary):
#     bytes = list(enumerate(chunks(binary, 1)))
#     return "\n".join(("{}".format(format_word_bin(x)) for i, x in bytes))


# def format_binary(binary):
#     bytes = list(enumerate(chunks(binary, 1)))
#     num_bytes = len(bytes)
#     return num_bytes, "\n".join(("{:03}: byte_array[7:0] = 8'h{}".format(i, format_word_hex(x), i) for i, x in bytes))

if args.arm_rom:
    bytes = format_arm_rom(binary)
    print(bytes)

if args.sv_module:
    num_bytes, bytes = format_binary(binary)

    # Emit the code.
    print("""
    // Copyright 2020 ETH Zurich
    // SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
    //
    // Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
    // Florian Zaruba <zarubaf@iis.ee.ethz.ch>
    // Stefan Mach <smach@iis.ee.ethz.ch>
    // Thomas Benz <tbenz@iis.ee.ethz.ch>
    // Paul Scheffler <paulsc@iis.ee.ethz.ch>
    // Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
    //
    // AUTOMATICALLY GENERATED by {script}; edit the script instead.

    module {module_name} #(
        parameter int unsigned AddrWidth = 32,
        parameter int unsigned DataWidth = 32,
        parameter int unsigned BASE = 3
    )(
        input  logic                 clk_i,
        input  logic                 rst_ni,
        input  logic                 req_i,
        input  logic [AddrWidth-1:0] addr_i,
        output logic [DataWidth-1:0] data_o
    );
        localparam NumBytes = {num_bytes};
        logic [$clog2(NumBytes)-1:0][7:0] byte_array;
          
        localparam RomSize = $clog2(NumBytes) / (DataWidth / 8);
        localparam logic [RomSize-1:0][DataWidth-1:0] rom;
          
        data_o = rom[addr_i];
        data_o = {rom[addr_i],rom[addr_i+1]};

        always comb begin
          unique case ()
            {bytes};
                default: byte_array[7:0] = 8'h00;
            endcase
          unique case ()
            {bytes};
                default: byte_array[7:0] = 8'h00;
            endcase
        end    

        assign data_o = rom;
    endmodule
    """.strip().format(
        script=os.path.basename(__file__),
        module_name=args.sv_module,
        num_bytes=num_bytes,
        bytes=bytes,
    ))
