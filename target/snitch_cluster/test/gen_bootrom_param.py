#!/usr/bin/env python3
#
# Copyright 2020 ETH Zurich
# SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
#
# Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
# Florian Zaruba <zarubaf@iis.ee.ethz.ch>
# Stefan Mach <smach@iis.ee.ethz.ch>
# Thomas Benz <tbenz@iis.ee.ethz.ch>
# Paul Scheffler <paulsc@iis.ee.ethz.ch>
# Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
# Gianna Paulin <pauling@iis.ee.ethz.ch>
# Tim Fischer <fischeti@iis.ee.ethz.ch>

import os
import argparse

from struct import *

# Parse arguments.
parser = argparse.ArgumentParser(description="Generate thestral_bootrom.sv")
parser.add_argument("BINARY",
                    help="Binary image for which to create a bootrom")
parser.add_argument(
    "--sv-module",
    "-m",
    metavar="BINARY",
    help=
    "Combinatorial SystemVerilog module with `reg_interface`. Name of the SystemVerilog module"
)
# Parse arguments.
parser.add_argument(
    "-p",
    "--pad",
    action="store",
    default=0,
    type=int,
    help=
    "Pad to next power of two (if the value is not a power of two it is rounded appropriately)"
)
parser.add_argument("--arm-rom",
                    action="store_true",
                    help="Generate am Arm ROM code file.")
args = parser.parse_args()

# Read the bootrom binary.
with open(args.BINARY, "rb") as file:
    binary = file.read()

# Calculate length of bootrom.
# Fill up the binary with zeroes to the next power of two.
length = 8
while length < max(len(binary), args.pad):
    length *= 2

binary += b"\0" * (length - len(binary))

# Generate the bytes to be emitted.
def chunks(seq, size):
    return (seq[pos:pos + size] for pos in range(0, len(seq), size))


def format_word_bin(word):
    hex = ["{:08b}".format(int(x)) for x in word]
    return "".join(reversed(hex))


def format_arm_rom(binary):
    bytes = list(enumerate(chunks(binary, 1)))
    return "\n".join(("{}".format(format_word_bin(x)) for i, x in bytes))


if args.arm_rom:
    bytes = format_arm_rom(binary)
    print(bytes)

def create_rom(binary):
    b = bytearray(binary).hex()
    num_bytes = len(b)
    return int(num_bytes / 2), "\n            ".join(
        ("{{8'h{}}}, /* 0x{:04x} */".format(
            str(b[i]) + str(b[i + 1]), int(i / 2)) for i in range(num_bytes - 2, 0, -2))) + "\n            {{8'h{}}}  /* 0x{:04x} */".format(
                str(b[0]) + str(b[1]), 0)

def assign_word():
    MaxDataWidth = 512 / 8
    return "".join("rom[addr_i+{}][7:0],\n                             ".format(i) for i in range(int(MaxDataWidth) - 1, 0, -1))

if args.sv_module:
    num_bytes, bytes = create_rom(binary)
    word = assign_word()

    # Emit the code.
    print("""
    // Copyright 2020 ETH Zurich
    // SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1
    //
    // Fabian Schuiki <fschuiki@iis.ee.ethz.ch>
    // Florian Zaruba <zarubaf@iis.ee.ethz.ch>
    // Stefan Mach <smach@iis.ee.ethz.ch>
    // Thomas Benz <tbenz@iis.ee.ethz.ch>
    // Paul Scheffler <paulsc@iis.ee.ethz.ch>
    // Wolfgang Roenninger <wroennin@iis.ee.ethz.ch>
    //
    // AUTOMATICALLY GENERATED by {script}; edit the script instead.

    module {module_name} #(
        parameter int unsigned AddrWidth = 32,
        parameter int unsigned DataWidth = 32,
        parameter int unsigned BootromSize = 65536
    )(
        input  logic                 clk_i,
        input  logic                 rst_ni,
        input  logic [AddrWidth-1:0] addr_i,
        output logic [DataWidth-1:0] data_o
    );
        localparam logic [{gen_size}-1:0][7:0] rom = '{{
            {bytes}
        }};
        
        localparam int unsigned NumBytes = DataWidth/8;
        localparam int unsigned WordOffset = $clog2(NumBytes);
        logic [BootromSize/NumBytes-1:0][DataWidth-1:0] rom_word_addressed;
        assign rom_word_addressed = rom[{gen_size}-1:({gen_size}-1)-BootromSize];

        logic [$clog2(BootromSize)-1:WordOffset] aligned_address;

        assign aligned_address = addr_i[$clog2(BootromSize)-1:WordOffset];

        assign data_o = rom_word_addressed[aligned_address];
        
    endmodule
    """.strip().format(
        script=os.path.basename(__file__),
        module_name=args.sv_module,
        gen_size=args.pad,
        num_bytes=num_bytes,
        bytes=bytes,
        word=word,
    ))