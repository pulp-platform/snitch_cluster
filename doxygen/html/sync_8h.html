<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Snitch Runtime: sw/runtime/src/sync.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Snitch Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_01fcd3835fb4e7d9331b722d86291b65.html">sw</a></li><li class="navelem"><a class="el" href="dir_91df2be89c28e297cb810089bc4b097d.html">runtime</a></li><li class="navelem"><a class="el" href="dir_69aa9ef050bce056c0b3e6dc15051512.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">sync.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This file provides functions to synchronize Snitch cores.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;../../deps/riscv-opcodes/encoding.h&quot;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div>
<p><a href="sync_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a39380f9772daa6eaf642d5e113b4eb36" id="r_a39380f9772daa6eaf642d5e113b4eb36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39380f9772daa6eaf642d5e113b4eb36">snrt_comm_init</a> ()</td></tr>
<tr class="memdesc:a39380f9772daa6eaf642d5e113b4eb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the world communicator.  <br /></td></tr>
<tr class="separator:a39380f9772daa6eaf642d5e113b4eb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174856791d8bccb542df6a8f4ad0f278" id="r_a174856791d8bccb542df6a8f4ad0f278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a174856791d8bccb542df6a8f4ad0f278">snrt_comm_create</a> (uint32_t size, <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> *communicator)</td></tr>
<tr class="memdesc:a174856791d8bccb542df6a8f4ad0f278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a communicator object.  <br /></td></tr>
<tr class="separator:a174856791d8bccb542df6a8f4ad0f278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ae0f42550fc0d5551f167f2f64a7d" id="r_a572ae0f42550fc0d5551f167f2f64a7d"><td class="memItemLeft" align="right" valign="top">volatile uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572ae0f42550fc0d5551f167f2f64a7d">snrt_mutex</a> ()</td></tr>
<tr class="memdesc:a572ae0f42550fc0d5551f167f2f64a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to a mutex variable.  <br /></td></tr>
<tr class="separator:a572ae0f42550fc0d5551f167f2f64a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321bade577f4b200a5ad8aa37f281a61" id="r_a321bade577f4b200a5ad8aa37f281a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a321bade577f4b200a5ad8aa37f281a61">snrt_mutex_acquire</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:a321bade577f4b200a5ad8aa37f281a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a mutex, blocking.  <br /></td></tr>
<tr class="separator:a321bade577f4b200a5ad8aa37f281a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25632cce8737bb2726e18ed1b4f267cf" id="r_a25632cce8737bb2726e18ed1b4f267cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25632cce8737bb2726e18ed1b4f267cf">snrt_mutex_ttas_acquire</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:a25632cce8737bb2726e18ed1b4f267cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a mutex, blocking.  <br /></td></tr>
<tr class="separator:a25632cce8737bb2726e18ed1b4f267cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4e4b77fd2b4ce02f0235348745a57" id="r_ad0c4e4b77fd2b4ce02f0235348745a57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0c4e4b77fd2b4ce02f0235348745a57">snrt_mutex_release</a> (volatile uint32_t *pmtx)</td></tr>
<tr class="memdesc:ad0c4e4b77fd2b4ce02f0235348745a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously-acquired mutex.  <br /></td></tr>
<tr class="separator:ad0c4e4b77fd2b4ce02f0235348745a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179e079601e5f639db4748c5dcd70bbb" id="r_a179e079601e5f639db4748c5dcd70bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a179e079601e5f639db4748c5dcd70bbb">snrt_wake_clusters</a> (uint32_t core_mask, <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="memdesc:a179e079601e5f639db4748c5dcd70bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake the clusters belonging to a given communicator. Can only be called by a single core in the whole system!  <br /></td></tr>
<tr class="separator:a179e079601e5f639db4748c5dcd70bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac365cea67efa78cefdddecadf3e08d20" id="r_ac365cea67efa78cefdddecadf3e08d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a> ()</td></tr>
<tr class="memdesc:ac365cea67efa78cefdddecadf3e08d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize cores in a cluster with a hardware barrier, blocking.  <br /></td></tr>
<tr class="separator:ac365cea67efa78cefdddecadf3e08d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2a2bcf9c3db33b7c54c9d0600fea70" id="r_aef2a2bcf9c3db33b7c54c9d0600fea70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef2a2bcf9c3db33b7c54c9d0600fea70">snrt_inter_cluster_sw_barrier</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="separator:aef2a2bcf9c3db33b7c54c9d0600fea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7099d671dde85c7bb410caffcceefa" id="r_a7e7099d671dde85c7bb410caffcceefa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="memdesc:a7e7099d671dde85c7bb410caffcceefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize one core from every cluster with the others.  <br /></td></tr>
<tr class="separator:a7e7099d671dde85c7bb410caffcceefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7747eeef4917ff7ba59e7c5f94eb3aaf" id="r_a7747eeef4917ff7ba59e7c5f94eb3aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7747eeef4917ff7ba59e7c5f94eb3aaf">snrt_global_sw_barrier</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm)</td></tr>
<tr class="separator:a7747eeef4917ff7ba59e7c5f94eb3aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9824f88cb2c0dfdc68e5d6052978975e" id="r_a9824f88cb2c0dfdc68e5d6052978975e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm)</td></tr>
<tr class="memdesc:a9824f88cb2c0dfdc68e5d6052978975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize all Snitch cores.  <br /></td></tr>
<tr class="separator:a9824f88cb2c0dfdc68e5d6052978975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009fca3dd0749c28446bf4a9f86cb211" id="r_a009fca3dd0749c28446bf4a9f86cb211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a009fca3dd0749c28446bf4a9f86cb211">snrt_partial_barrier</a> (<a class="el" href="structsnrt__barrier__t.html">snrt_barrier_t</a> *barr, uint32_t n)</td></tr>
<tr class="memdesc:a009fca3dd0749c28446bf4a9f86cb211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic software barrier.  <br /></td></tr>
<tr class="separator:a009fca3dd0749c28446bf4a9f86cb211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed7d49a94d35c044bc0701b9af191fd" id="r_a9ed7d49a94d35c044bc0701b9af191fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ed7d49a94d35c044bc0701b9af191fd">snrt_global_all_to_all_reduction</a> (uint32_t value)</td></tr>
<tr class="memdesc:a9ed7d49a94d35c044bc0701b9af191fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a global sum reduction, blocking.  <br /></td></tr>
<tr class="separator:a9ed7d49a94d35c044bc0701b9af191fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5dfba8b5aa911c9af7fc253fc119ac" id="r_a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f5dfba8b5aa911c9af7fc253fc119ac">snrt_global_reduction_dma</a> (T *dst_buffer, T *src_buffer, size_t len, <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm=NULL)</td></tr>
<tr class="memdesc:a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a sum reduction among clusters, blocking.  <br /></td></tr>
<tr class="separator:a8f5dfba8b5aa911c9af7fc253fc119ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6988e3d8671188ea63fa9a127963ebcb" id="r_a6988e3d8671188ea63fa9a127963ebcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a> (uint32_t val)</td></tr>
<tr class="memdesc:a6988e3d8671188ea63fa9a127963ebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure value is written back to the register file.  <br /></td></tr>
<tr class="separator:a6988e3d8671188ea63fa9a127963ebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c67f898bda83ec08d38643eb4fc412" id="r_a02c67f898bda83ec08d38643eb4fc412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02c67f898bda83ec08d38643eb4fc412">snrt_set_awuser</a> (uint64_t field)</td></tr>
<tr class="memdesc:a02c67f898bda83ec08d38643eb4fc412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable LSU AW user field.  <br /></td></tr>
<tr class="separator:a02c67f898bda83ec08d38643eb4fc412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a656ad0f51a364864f0e787eb27ec6d" id="r_a7a656ad0f51a364864f0e787eb27ec6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a656ad0f51a364864f0e787eb27ec6d">snrt_set_awuser_low</a> (uint32_t field)</td></tr>
<tr class="separator:a7a656ad0f51a364864f0e787eb27ec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3ea3c17c3d559a48c2979f6a020f21" id="r_ada3ea3c17c3d559a48c2979f6a020f21"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada3ea3c17c3d559a48c2979f6a020f21">snrt_get_collective_mask</a> (<a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> comm)</td></tr>
<tr class="separator:ada3ea3c17c3d559a48c2979f6a020f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead031db6bba69af7489b18297b08d33" id="r_aead031db6bba69af7489b18297b08d33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aead031db6bba69af7489b18297b08d33">snrt_enable_multicast</a> (uint64_t mask)</td></tr>
<tr class="memdesc:aead031db6bba69af7489b18297b08d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable LSU multicast.  <br /></td></tr>
<tr class="separator:aead031db6bba69af7489b18297b08d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3597f143342fb37d0564409eec33016" id="r_ae3597f143342fb37d0564409eec33016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3597f143342fb37d0564409eec33016">snrt_disable_multicast</a> ()</td></tr>
<tr class="memdesc:ae3597f143342fb37d0564409eec33016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable LSU multicast.  <br /></td></tr>
<tr class="separator:ae3597f143342fb37d0564409eec33016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6482add065d074c5e0a8744ba3e6e4" id="r_a1a6482add065d074c5e0a8744ba3e6e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a6482add065d074c5e0a8744ba3e6e4">snrt_enable_reduction</a> (uint64_t mask, snrt_collective_opcode_t opcode)</td></tr>
<tr class="memdesc:a1a6482add065d074c5e0a8744ba3e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable LSU reduction.  <br /></td></tr>
<tr class="separator:a1a6482add065d074c5e0a8744ba3e6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad9ce058cc2f86b928ef4606f0064ea" id="r_aaad9ce058cc2f86b928ef4606f0064ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad9ce058cc2f86b928ef4606f0064ea">snrt_disable_reduction</a> ()</td></tr>
<tr class="memdesc:aaad9ce058cc2f86b928ef4606f0064ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable LSU reduction.  <br /></td></tr>
<tr class="separator:aaad9ce058cc2f86b928ef4606f0064ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae3a9acd2f4afcb8d04b26fea730129a8" id="r_ae3a9acd2f4afcb8d04b26fea730129a8"><td class="memItemLeft" align="right" valign="top">__thread <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a9acd2f4afcb8d04b26fea730129a8">snrt_comm_world_info</a></td></tr>
<tr class="separator:ae3a9acd2f4afcb8d04b26fea730129a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7980efac657f907e499680846b99f216" id="r_a7980efac657f907e499680846b99f216"><td class="memItemLeft" align="right" valign="top"><a id="a7980efac657f907e499680846b99f216" name="a7980efac657f907e499680846b99f216"></a>
__thread <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>snrt_comm_world</b></td></tr>
<tr class="separator:a7980efac657f907e499680846b99f216"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides functions to synchronize Snitch cores. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac365cea67efa78cefdddecadf3e08d20" name="ac365cea67efa78cefdddecadf3e08d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac365cea67efa78cefdddecadf3e08d20">&#9670;&#160;</a></span>snrt_cluster_hw_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_cluster_hw_barrier </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize cores in a cluster with a hardware barrier, blocking. </p>
<dl class="section note"><dt>Note</dt><dd>Synchronizes all (both DM and compute) cores. All cores must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  204</span>                                      {</div>
<div class="line"><span class="lineno">  205</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;csrr x0, barrier&quot;</span> ::: <span class="stringliteral">&quot;memory&quot;</span>);</div>
<div class="line"><span class="lineno">  206</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a174856791d8bccb542df6a8f4ad0f278" name="a174856791d8bccb542df6a8f4ad0f278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174856791d8bccb542df6a8f4ad0f278">&#9670;&#160;</a></span>snrt_comm_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_comm_create </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a> *</td>          <td class="paramname"><span class="paramname"><em>communicator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a communicator object. </p>
<p>The newly created communicator object includes the first <code>size</code> clusters. All clusters, even those which are not part of the communicator, must invoke this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of clusters to include in the communicator. </td></tr>
    <tr><td class="paramname">communicator</td><td>Pointer to the communicator object to be created. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">   74</span>                                                                       {</div>
<div class="line"><span class="lineno">   75</span>    <span class="comment">// Allocate communicator struct in L1 and point to it.</span></div>
<div class="line"><span class="lineno">   76</span>    *communicator =</div>
<div class="line"><span class="lineno">   77</span>        (<a class="code hl_struct" href="structsnrt__comm__info__t.html">snrt_comm_t</a>)snrt_l1_alloc_cluster_local(<span class="keyword">sizeof</span>(<a class="code hl_struct" href="structsnrt__comm__info__t.html">snrt_comm_info_t</a>));</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>    <span class="comment">// Allocate barrier counter in L1. This allows us to perform global</span></div>
<div class="line"><span class="lineno">   80</span>    <span class="comment">// hardware barriers, as reductions are currently not supported in L3.</span></div>
<div class="line"><span class="lineno">   81</span>    <span class="comment">// All clusters allocate a barrier counter because we want to keep all</span></div>
<div class="line"><span class="lineno">   82</span>    <span class="comment">// clusters&#39; L1 allocators aligned, but only the zero-th cluster&#39;s is</span></div>
<div class="line"><span class="lineno">   83</span>    <span class="comment">// actually used. So all clusters allocate one, but only the zero-th</span></div>
<div class="line"><span class="lineno">   84</span>    <span class="comment">// cluster&#39;s is initialized. A global barrier is then used to ensure</span></div>
<div class="line"><span class="lineno">   85</span>    <span class="comment">// all cores &quot;see&quot; the initialized value.</span></div>
<div class="line"><span class="lineno">   86</span>    <span class="keywordtype">void</span> *barrier_ptr = snrt_l1_alloc_cluster_local(<span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><span class="lineno">   87</span>    barrier_ptr = snrt_remote_l1_ptr(barrier_ptr, snrt_cluster_idx(), 0);</div>
<div class="line"><span class="lineno">   88</span>    <span class="keywordflow">if</span> (snrt_global_core_idx() == 0) *(uint32_t *)barrier_ptr = 0;</div>
<div class="line"><span class="lineno">   89</span>    <a class="code hl_function" href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a>();</div>
<div class="line"><span class="lineno">   90</span> </div>
<div class="line"><span class="lineno">   91</span>    <span class="comment">// Initialize communicator, pointing to the newly-allocated barrier</span></div>
<div class="line"><span class="lineno">   92</span>    <span class="comment">// counter in L3.</span></div>
<div class="line"><span class="lineno">   93</span>    (*communicator)-&gt;size = size;</div>
<div class="line"><span class="lineno">   94</span>    (*communicator)-&gt;base = 0;</div>
<div class="line"><span class="lineno">   95</span>    (*communicator)-&gt;mask = size - 1;</div>
<div class="line"><span class="lineno">   96</span>    (*communicator)-&gt;barrier_ptr = (uint32_t *)barrier_ptr;</div>
<div class="line"><span class="lineno">   97</span>    (*communicator)-&gt;is_participant = snrt_cluster_idx() &lt; size;</div>
<div class="line"><span class="lineno">   98</span>}</div>
<div class="ttc" id="astructsnrt__comm__info__t_html"><div class="ttname"><a href="structsnrt__comm__info__t.html">snrt_comm_info_t</a></div><div class="ttdef"><b>Definition</b> sync_decls.h:14</div></div>
<div class="ttc" id="async_8h_html_a9824f88cb2c0dfdc68e5d6052978975e"><div class="ttname"><a href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a></div><div class="ttdeci">void snrt_global_barrier(snrt_comm_t comm)</div><div class="ttdoc">Synchronize all Snitch cores.</div><div class="ttdef"><b>Definition</b> sync.h:290</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a39380f9772daa6eaf642d5e113b4eb36" name="a39380f9772daa6eaf642d5e113b4eb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39380f9772daa6eaf642d5e113b4eb36">&#9670;&#160;</a></span>snrt_comm_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_comm_init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the world communicator. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called before using any of the inter-cluster synchronization functions. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">   32</span>                             {</div>
<div class="line"><span class="lineno">   33</span>    <span class="comment">// Point to default-initialized communicator struct, with barrier pointer</span></div>
<div class="line"><span class="lineno">   34</span>    <span class="comment">// in L3.</span></div>
<div class="line"><span class="lineno">   35</span>    snrt_comm_world = &amp;snrt_comm_world_info;</div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span>    <span class="comment">// Allocate barrier counter in L1. This allows us to perform global</span></div>
<div class="line"><span class="lineno">   38</span>    <span class="comment">// hardware barriers, as reductions are currently not supported in L3.</span></div>
<div class="line"><span class="lineno">   39</span>    <span class="comment">// All clusters allocate a barrier counter because we want to keep all</span></div>
<div class="line"><span class="lineno">   40</span>    <span class="comment">// clusters&#39; L1 allocators aligned, but only the zero-th cluster&#39;s is</span></div>
<div class="line"><span class="lineno">   41</span>    <span class="comment">// actually used. So all clusters allocate one, but only the zero-th</span></div>
<div class="line"><span class="lineno">   42</span>    <span class="comment">// cluster&#39;s is initialized. A global barrier is then used to ensure</span></div>
<div class="line"><span class="lineno">   43</span>    <span class="comment">// all cores &quot;see&quot; the initialized value. This global barrier uses the</span></div>
<div class="line"><span class="lineno">   44</span>    <span class="comment">// default-initialized barrier pointer in L3. It must thus be a software</span></div>
<div class="line"><span class="lineno">   45</span>    <span class="comment">// barrier, as we currently do not support hardware reductions in L3.</span></div>
<div class="line"><span class="lineno">   46</span>    <span class="keywordtype">void</span> *barrier_ptr = snrt_l1_alloc_cluster_local(<span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line"><span class="lineno">   47</span>    barrier_ptr = snrt_remote_l1_ptr(barrier_ptr, snrt_cluster_idx(), 0);</div>
<div class="line"><span class="lineno">   48</span>    <span class="keywordflow">if</span> (snrt_global_core_idx() == 0) {</div>
<div class="line"><span class="lineno">   49</span>        *(uint32_t *)barrier_ptr = 0;</div>
<div class="line"><span class="lineno">   50</span>        <span class="comment">// TODO(colluca): this is a workaround that shouldn&#39;t be necessary.</span></div>
<div class="line"><span class="lineno">   51</span>        <span class="comment">// It seems some tests expect the next pointer at the start of the</span></div>
<div class="line"><span class="lineno">   52</span>        <span class="comment">// user application to be aligned to the hyperbank.</span></div>
<div class="line"><span class="lineno">   53</span>        <span class="comment">// &gt; Should we get rid of the alloc_v1 API altogether and fix these?</span></div>
<div class="line"><span class="lineno">   54</span>        snrt_l1_update_next(snrt_l1_next_aligned_hyperbank());</div>
<div class="line"><span class="lineno">   55</span>    }</div>
<div class="line"><span class="lineno">   56</span>    snrt_global_sw_barrier();</div>
<div class="line"><span class="lineno">   57</span> </div>
<div class="line"><span class="lineno">   58</span>    <span class="comment">// Update the communicator struct, pointing to the barrier pointer in L1.</span></div>
<div class="line"><span class="lineno">   59</span>    <span class="comment">// This whole workaround is required because we cannot statically allocate</span></div>
<div class="line"><span class="lineno">   60</span>    <span class="comment">// variables in L1.</span></div>
<div class="line"><span class="lineno">   61</span>    snrt_comm_world-&gt;barrier_ptr = (uint32_t *)barrier_ptr;</div>
<div class="line"><span class="lineno">   62</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3597f143342fb37d0564409eec33016" name="ae3597f143342fb37d0564409eec33016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3597f143342fb37d0564409eec33016">&#9670;&#160;</a></span>snrt_disable_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_disable_multicast </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable LSU multicast. </p>
<div class="fragment"><div class="line"><span class="lineno">  498</span>{ <a class="code hl_function" href="#a02c67f898bda83ec08d38643eb4fc412">snrt_set_awuser</a>(0); }</div>
<div class="ttc" id="async_8h_html_a02c67f898bda83ec08d38643eb4fc412"><div class="ttname"><a href="#a02c67f898bda83ec08d38643eb4fc412">snrt_set_awuser</a></div><div class="ttdeci">void snrt_set_awuser(uint64_t field)</div><div class="ttdoc">Enable LSU AW user field.</div><div class="ttdef"><b>Definition</b> sync.h:464</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaad9ce058cc2f86b928ef4606f0064ea" name="aaad9ce058cc2f86b928ef4606f0064ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad9ce058cc2f86b928ef4606f0064ea">&#9670;&#160;</a></span>snrt_disable_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_disable_reduction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable LSU reduction. </p>
<div class="fragment"><div class="line"><span class="lineno">  522</span>{ <a class="code hl_function" href="#a02c67f898bda83ec08d38643eb4fc412">snrt_set_awuser</a>(0); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aead031db6bba69af7489b18297b08d33" name="aead031db6bba69af7489b18297b08d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead031db6bba69af7489b18297b08d33">&#9670;&#160;</a></span>snrt_enable_multicast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_enable_multicast </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable LSU multicast. </p>
<p>All stores performed after this call will be multicast to all addresses specified by the address and mask pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Multicast mask value </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  488</span>                                                 {</div>
<div class="line"><span class="lineno">  489</span>    <a class="code hl_union" href="unionsnrt__collective__t.html">snrt_collective_t</a> op;</div>
<div class="line"><span class="lineno">  490</span>    op.f.opcode = SNRT_COLLECTIVE_MULTICAST;</div>
<div class="line"><span class="lineno">  491</span>    op.f.mask = mask;</div>
<div class="line"><span class="lineno">  492</span>    <a class="code hl_function" href="#a02c67f898bda83ec08d38643eb4fc412">snrt_set_awuser</a>(op.w);</div>
<div class="line"><span class="lineno">  493</span>}</div>
<div class="ttc" id="aunionsnrt__collective__t_html"><div class="ttname"><a href="unionsnrt__collective__t.html">snrt_collective_t</a></div><div class="ttdef"><b>Definition</b> sync_decls.h:40</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a6482add065d074c5e0a8744ba3e6e4" name="a1a6482add065d074c5e0a8744ba3e6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6482add065d074c5e0a8744ba3e6e4">&#9670;&#160;</a></span>snrt_enable_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_enable_reduction </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">snrt_collective_opcode_t</td>          <td class="paramname"><span class="paramname"><em>opcode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable LSU reduction. </p>
<p>All stores performed after this call will be reductions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask defines all involved members </td></tr>
    <tr><td class="paramname">opcode</td><td>Type of reduction operation </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  512</span>                                                                   {</div>
<div class="line"><span class="lineno">  513</span>    <a class="code hl_union" href="unionsnrt__collective__t.html">snrt_collective_t</a> op;</div>
<div class="line"><span class="lineno">  514</span>    op.f.opcode = opcode;</div>
<div class="line"><span class="lineno">  515</span>    op.f.mask = mask;</div>
<div class="line"><span class="lineno">  516</span>    <a class="code hl_function" href="#a02c67f898bda83ec08d38643eb4fc412">snrt_set_awuser</a>(op.w);</div>
<div class="line"><span class="lineno">  517</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ada3ea3c17c3d559a48c2979f6a020f21" name="ada3ea3c17c3d559a48c2979f6a020f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3ea3c17c3d559a48c2979f6a020f21">&#9670;&#160;</a></span>snrt_get_collective_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t snrt_get_collective_mask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  473</span>                                                           {</div>
<div class="line"><span class="lineno">  474</span>    <span class="keywordflow">return</span> comm-&gt;mask * SNRT_CLUSTER_OFFSET;</div>
<div class="line"><span class="lineno">  475</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ed7d49a94d35c044bc0701b9af191fd" name="a9ed7d49a94d35c044bc0701b9af191fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed7d49a94d35c044bc0701b9af191fd">&#9670;&#160;</a></span>snrt_global_all_to_all_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t snrt_global_all_to_all_reduction </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a global sum reduction, blocking. </p>
<p>All cores participate in the reduction and synchronize globally to wait for the reduction to complete. The synchronization is performed via snrt_global_barrier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be summed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the sum reduction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Every Snitch core must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  340</span>                                                                 {</div>
<div class="line"><span class="lineno">  341</span>    <span class="comment">// Reduce cores within cluster in TCDM</span></div>
<div class="line"><span class="lineno">  342</span>    uint32_t *cluster_result = &amp;(snrt_cls()-&gt;reduction);</div>
<div class="line"><span class="lineno">  343</span>    uint32_t tmp = __atomic_fetch_add(cluster_result, value, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span>    <span class="comment">// Wait for writeback to ensure AMO is seen by all cores after barrier</span></div>
<div class="line"><span class="lineno">  346</span>    <a class="code hl_function" href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a>(tmp);</div>
<div class="line"><span class="lineno">  347</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  348</span> </div>
<div class="line"><span class="lineno">  349</span>    <span class="comment">// Reduce DM cores across clusters in global memory</span></div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">if</span> (snrt_is_dm_core()) {</div>
<div class="line"><span class="lineno">  351</span>        __atomic_add_fetch(&amp;_reduction_result, *cluster_result,</div>
<div class="line"><span class="lineno">  352</span>                           __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  353</span>        <a class="code hl_function" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a>();</div>
<div class="line"><span class="lineno">  354</span>        *cluster_result = _reduction_result;</div>
<div class="line"><span class="lineno">  355</span>    }</div>
<div class="line"><span class="lineno">  356</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  357</span>    <span class="keywordflow">return</span> *cluster_result;</div>
<div class="line"><span class="lineno">  358</span>}</div>
<div class="ttc" id="async_8h_html_a6988e3d8671188ea63fa9a127963ebcb"><div class="ttname"><a href="#a6988e3d8671188ea63fa9a127963ebcb">snrt_wait_writeback</a></div><div class="ttdeci">void snrt_wait_writeback(uint32_t val)</div><div class="ttdoc">Ensure value is written back to the register file.</div><div class="ttdef"><b>Definition</b> sync.h:449</div></div>
<div class="ttc" id="async_8h_html_a7e7099d671dde85c7bb410caffcceefa"><div class="ttname"><a href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a></div><div class="ttdeci">static void snrt_inter_cluster_barrier(snrt_comm_t comm=NULL)</div><div class="ttdoc">Synchronize one core from every cluster with the others.</div><div class="ttdef"><b>Definition</b> sync.h:241</div></div>
<div class="ttc" id="async_8h_html_ac365cea67efa78cefdddecadf3e08d20"><div class="ttname"><a href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a></div><div class="ttdeci">void snrt_cluster_hw_barrier()</div><div class="ttdoc">Synchronize cores in a cluster with a hardware barrier, blocking.</div><div class="ttdef"><b>Definition</b> sync.h:204</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9824f88cb2c0dfdc68e5d6052978975e" name="a9824f88cb2c0dfdc68e5d6052978975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9824f88cb2c0dfdc68e5d6052978975e">&#9670;&#160;</a></span>snrt_global_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize all Snitch cores. </p>
<p>Synchronization is performed hierarchically. Within a cluster, cores are synchronized through a hardware barrier (see snrt_cluster_hw_barrier). Clusters are synchronized through a software barrier (see <a class="el" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters synchronize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Every Snitch core must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  290</span>                                                  {</div>
<div class="line"><span class="lineno">  291</span>    <span class="comment">// Synchronize cores in a cluster with the HW barrier</span></div>
<div class="line"><span class="lineno">  292</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  293</span> </div>
<div class="line"><span class="lineno">  294</span>    <span class="comment">// Synchronize all clusters</span></div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">if</span> (snrt_is_dm_core()) {</div>
<div class="line"><span class="lineno">  296</span>        <a class="code hl_function" href="#a7e7099d671dde85c7bb410caffcceefa">snrt_inter_cluster_barrier</a>(comm);</div>
<div class="line"><span class="lineno">  297</span>    }</div>
<div class="line"><span class="lineno">  298</span> </div>
<div class="line"><span class="lineno">  299</span>    <span class="comment">// Synchronize cores in a cluster with the HW barrier</span></div>
<div class="line"><span class="lineno">  300</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  301</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f5dfba8b5aa911c9af7fc253fc119ac" name="a8f5dfba8b5aa911c9af7fc253fc119ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5dfba8b5aa911c9af7fc253fc119ac">&#9670;&#160;</a></span>snrt_global_reduction_dma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_reduction_dma </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>dst_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>src_buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a sum reduction among clusters, blocking. </p>
<p>The reduction is performed in a logarithmic fashion. Half of the clusters active in every level of the binary-tree participate as as senders, the other half as receivers. Senders use the DMA to send their data to the respective receiver's destination buffer. The receiver then reduces each element in its destination buffer with the respective element in its source buffer. The result is stored in the source buffer. It then proceeds to the next level in the binary tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_buffer</td><td>The pointer to the calling cluster's destination buffer. </td></tr>
    <tr><td class="paramname">src_buffer</td><td>The pointer to the calling cluster's source buffer. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data in each buffer. Only integer multiples of the number of compute cores are supported at the moment. </td></tr>
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters participate in the reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The destination buffers must lie at the same offset in every cluster's TCDM. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  381</span>                                                               {</div>
<div class="line"><span class="lineno">  382</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  383</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  384</span> </div>
<div class="line"><span class="lineno">  385</span>    <span class="comment">// If we have a single cluster, no reduction has to be done</span></div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">if</span> (comm-&gt;size &gt; 1) {</div>
<div class="line"><span class="lineno">  387</span>        <span class="comment">// DMA core will send compute cores&#39; data, so it must wait on it</span></div>
<div class="line"><span class="lineno">  388</span>        <span class="comment">// to be available</span></div>
<div class="line"><span class="lineno">  389</span>        snrt_fpu_fence();</div>
<div class="line"><span class="lineno">  390</span>        <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  391</span> </div>
<div class="line"><span class="lineno">  392</span>        <span class="comment">// Iterate levels in the binary reduction tree</span></div>
<div class="line"><span class="lineno">  393</span>        <span class="keywordtype">int</span> num_levels = ceil(log2(comm-&gt;size));</div>
<div class="line"><span class="lineno">  394</span>        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; num_levels; level++) {</div>
<div class="line"><span class="lineno">  395</span>            <span class="comment">// Determine whether the current cluster is an active cluster.</span></div>
<div class="line"><span class="lineno">  396</span>            <span class="comment">// An active cluster is a cluster that participates in the current</span></div>
<div class="line"><span class="lineno">  397</span>            <span class="comment">// level of the reduction tree. Every second cluster among the</span></div>
<div class="line"><span class="lineno">  398</span>            <span class="comment">// active ones is a sender.</span></div>
<div class="line"><span class="lineno">  399</span>            uint32_t is_active = (snrt_cluster_idx() % (1 &lt;&lt; level)) == 0;</div>
<div class="line"><span class="lineno">  400</span>            uint32_t is_sender = (snrt_cluster_idx() % (1 &lt;&lt; (level + 1))) != 0;</div>
<div class="line"><span class="lineno">  401</span> </div>
<div class="line"><span class="lineno">  402</span>            <span class="comment">// If the cluster is a sender, it sends the data in its source</span></div>
<div class="line"><span class="lineno">  403</span>            <span class="comment">// buffer to the respective receiver&#39;s destination buffer</span></div>
<div class="line"><span class="lineno">  404</span>            <span class="keywordflow">if</span> (is_active &amp;&amp; is_sender) {</div>
<div class="line"><span class="lineno">  405</span>                <span class="keywordflow">if</span> (!snrt_is_compute_core()) {</div>
<div class="line"><span class="lineno">  406</span>                    uint64_t dst = (uint64_t)dst_buffer -</div>
<div class="line"><span class="lineno">  407</span>                                   (1 &lt;&lt; level) * SNRT_CLUSTER_OFFSET;</div>
<div class="line"><span class="lineno">  408</span>                    <a class="code hl_function" href="dma_8h.html#a5742834ee8f96e897dfd5d3fe1e2fedb">snrt_dma_start_1d</a>(dst, (uint64_t)src_buffer,</div>
<div class="line"><span class="lineno">  409</span>                                      len * <span class="keyword">sizeof</span>(T));</div>
<div class="line"><span class="lineno">  410</span>                    <a class="code hl_function" href="dma_8h.html#aea9b2089c25300d67fed14450b21325a">snrt_dma_wait_all</a>();</div>
<div class="line"><span class="lineno">  411</span>                }</div>
<div class="line"><span class="lineno">  412</span>            }</div>
<div class="line"><span class="lineno">  413</span> </div>
<div class="line"><span class="lineno">  414</span>            <span class="comment">// Synchronize senders and receivers</span></div>
<div class="line"><span class="lineno">  415</span>            <a class="code hl_function" href="#a9824f88cb2c0dfdc68e5d6052978975e">snrt_global_barrier</a>(comm);</div>
<div class="line"><span class="lineno">  416</span> </div>
<div class="line"><span class="lineno">  417</span>            <span class="comment">// Every cluster which is not a sender performs the reduction</span></div>
<div class="line"><span class="lineno">  418</span>            <span class="keywordflow">if</span> (is_active &amp;&amp; !is_sender) {</div>
<div class="line"><span class="lineno">  419</span>                <span class="comment">// Computation is parallelized over the compute cores</span></div>
<div class="line"><span class="lineno">  420</span>                <span class="keywordflow">if</span> (snrt_is_compute_core()) {</div>
<div class="line"><span class="lineno">  421</span>                    uint32_t items_per_core =</div>
<div class="line"><span class="lineno">  422</span>                        len / snrt_cluster_compute_core_num();</div>
<div class="line"><span class="lineno">  423</span>                    uint32_t core_offset =</div>
<div class="line"><span class="lineno">  424</span>                        snrt_cluster_core_idx() * items_per_core;</div>
<div class="line"><span class="lineno">  425</span>                    <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; items_per_core; i++) {</div>
<div class="line"><span class="lineno">  426</span>                        uint32_t abs_i = core_offset + i;</div>
<div class="line"><span class="lineno">  427</span>                        src_buffer[abs_i] += dst_buffer[abs_i];</div>
<div class="line"><span class="lineno">  428</span>                    }</div>
<div class="line"><span class="lineno">  429</span>                }</div>
<div class="line"><span class="lineno">  430</span>            }</div>
<div class="line"><span class="lineno">  431</span> </div>
<div class="line"><span class="lineno">  432</span>            <span class="comment">// Synchronize compute and DM cores for next tree level</span></div>
<div class="line"><span class="lineno">  433</span>            snrt_fpu_fence();</div>
<div class="line"><span class="lineno">  434</span>            <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  435</span>        }</div>
<div class="line"><span class="lineno">  436</span>    }</div>
<div class="line"><span class="lineno">  437</span>}</div>
<div class="ttc" id="adma_8h_html_a5742834ee8f96e897dfd5d3fe1e2fedb"><div class="ttname"><a href="dma_8h.html#a5742834ee8f96e897dfd5d3fe1e2fedb">snrt_dma_start_1d</a></div><div class="ttdeci">static uint32_t snrt_dma_start_1d(uint64_t dst, uint64_t src, size_t size, const uint32_t channel=0)</div><div class="ttdoc">Start an asynchronous 1D DMA transfer with 64-bit wide pointers on a specific DMA channel.</div><div class="ttdef"><b>Definition</b> dma.h:35</div></div>
<div class="ttc" id="adma_8h_html_aea9b2089c25300d67fed14450b21325a"><div class="ttname"><a href="dma_8h.html#aea9b2089c25300d67fed14450b21325a">snrt_dma_wait_all</a></div><div class="ttdeci">static void snrt_dma_wait_all(const uint32_t channel=0)</div><div class="ttdoc">Block until a specific DMA channel is idle.</div><div class="ttdef"><b>Definition</b> dma.h:364</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7747eeef4917ff7ba59e7c5f94eb3aaf" name="a7747eeef4917ff7ba59e7c5f94eb3aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7747eeef4917ff7ba59e7c5f94eb3aaf">&#9670;&#160;</a></span>snrt_global_sw_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_global_sw_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  267</span>                                                     {</div>
<div class="line"><span class="lineno">  268</span>    <span class="comment">// Synchronize cores in a cluster with the HW barrier</span></div>
<div class="line"><span class="lineno">  269</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  270</span> </div>
<div class="line"><span class="lineno">  271</span>    <span class="comment">// Synchronize all clusters</span></div>
<div class="line"><span class="lineno">  272</span>    <span class="keywordflow">if</span> (snrt_is_dm_core()) {</div>
<div class="line"><span class="lineno">  273</span>        snrt_inter_cluster_sw_barrier(comm);</div>
<div class="line"><span class="lineno">  274</span>    }</div>
<div class="line"><span class="lineno">  275</span> </div>
<div class="line"><span class="lineno">  276</span>    <span class="comment">// Synchronize cores in a cluster with the HW barrier</span></div>
<div class="line"><span class="lineno">  277</span>    <a class="code hl_function" href="#ac365cea67efa78cefdddecadf3e08d20">snrt_cluster_hw_barrier</a>();</div>
<div class="line"><span class="lineno">  278</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7e7099d671dde85c7bb410caffcceefa" name="a7e7099d671dde85c7bb410caffcceefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7099d671dde85c7bb410caffcceefa">&#9670;&#160;</a></span>snrt_inter_cluster_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void snrt_inter_cluster_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize one core from every cluster with the others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters synchronize. Only used when not employing HW reduction.</td></tr>
  </table>
  </dd>
</dl>
<p>Implemented as a software barrier. </p><dl class="section note"><dt>Note</dt><dd>One core per cluster participating in the barrier must invoke this function (the same across all clusters), or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  241</span>                                                                       {</div>
<div class="line"><span class="lineno">  242</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span>    <span class="comment">// If the current cluster is not a participant, return immediately.</span></div>
<div class="line"><span class="lineno">  246</span>    <span class="keywordflow">if</span> (!comm-&gt;is_participant) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  247</span> </div>
<div class="line"><span class="lineno">  248</span><span class="preprocessor">#ifdef SNRT_SUPPORTS_NARROW_REDUCTION</span></div>
<div class="line"><span class="lineno">  249</span>    <span class="comment">// Fetch the address for the reduction</span></div>
<div class="line"><span class="lineno">  250</span>    <span class="keyword">volatile</span> uint32_t *addr = comm-&gt;barrier_ptr;</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span>    <span class="comment">// Compose collective mask</span></div>
<div class="line"><span class="lineno">  253</span>    uint64_t mask = snrt_get_collective_mask(comm);</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>    <span class="comment">// Launch the reduction</span></div>
<div class="line"><span class="lineno">  256</span>    <a class="code hl_function" href="#a1a6482add065d074c5e0a8744ba3e6e4">snrt_enable_reduction</a>(mask, SNRT_REDUCTION_BARRIER);</div>
<div class="line"><span class="lineno">  257</span>    *addr = 0;</div>
<div class="line"><span class="lineno">  258</span>    <a class="code hl_function" href="#aaad9ce058cc2f86b928ef4606f0064ea">snrt_disable_reduction</a>();</div>
<div class="line"><span class="lineno">  259</span> </div>
<div class="line"><span class="lineno">  260</span>    <span class="comment">// Fence to wait until the reduction is finished</span></div>
<div class="line"><span class="lineno">  261</span>    snrt_fence();</div>
<div class="line"><span class="lineno">  262</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  263</span>    snrt_inter_cluster_sw_barrier(comm);</div>
<div class="line"><span class="lineno">  264</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  265</span>}</div>
<div class="ttc" id="async_8h_html_a1a6482add065d074c5e0a8744ba3e6e4"><div class="ttname"><a href="#a1a6482add065d074c5e0a8744ba3e6e4">snrt_enable_reduction</a></div><div class="ttdeci">void snrt_enable_reduction(uint64_t mask, snrt_collective_opcode_t opcode)</div><div class="ttdoc">Enable LSU reduction.</div><div class="ttdef"><b>Definition</b> sync.h:511</div></div>
<div class="ttc" id="async_8h_html_aaad9ce058cc2f86b928ef4606f0064ea"><div class="ttname"><a href="#aaad9ce058cc2f86b928ef4606f0064ea">snrt_disable_reduction</a></div><div class="ttdeci">void snrt_disable_reduction()</div><div class="ttdoc">Disable LSU reduction.</div><div class="ttdef"><b>Definition</b> sync.h:522</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aef2a2bcf9c3db33b7c54c9d0600fea70" name="aef2a2bcf9c3db33b7c54c9d0600fea70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2a2bcf9c3db33b7c54c9d0600fea70">&#9670;&#160;</a></span>snrt_inter_cluster_sw_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void snrt_inter_cluster_sw_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  208</span>                                                                          {</div>
<div class="line"><span class="lineno">  209</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  210</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span>    <span class="comment">// If the current cluster is not a participant, return immediately.</span></div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">if</span> (!comm-&gt;is_participant) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  214</span> </div>
<div class="line"><span class="lineno">  215</span>    <span class="comment">// Clusters participating in the barrier increment a shared counter.</span></div>
<div class="line"><span class="lineno">  216</span>    uint32_t cnt = __atomic_add_fetch(comm-&gt;barrier_ptr, 1, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  217</span> </div>
<div class="line"><span class="lineno">  218</span>    <span class="comment">// All but the last cluster arriving on the barrier enter WFI. The last</span></div>
<div class="line"><span class="lineno">  219</span>    <span class="comment">// cluster resets the counter for the next barrier (if any) and multicasts</span></div>
<div class="line"><span class="lineno">  220</span>    <span class="comment">// an interrupt to wake up the other clusters.</span></div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">if</span> (cnt == comm-&gt;size) {</div>
<div class="line"><span class="lineno">  222</span>        *(comm-&gt;barrier_ptr) = 0;</div>
<div class="line"><span class="lineno">  223</span>        snrt_fence();</div>
<div class="line"><span class="lineno">  224</span>        <a class="code hl_function" href="#a179e079601e5f639db4748c5dcd70bbb">snrt_wake_clusters</a>(1 &lt;&lt; snrt_cluster_core_idx(), comm);</div>
<div class="line"><span class="lineno">  225</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  226</span>        snrt_wfi();</div>
<div class="line"><span class="lineno">  227</span>    }</div>
<div class="line"><span class="lineno">  228</span>    <span class="comment">// Clear interrupt for next barrier (interrupt arrives also at sender)</span></div>
<div class="line"><span class="lineno">  229</span>    snrt_int_clr_mcip();</div>
<div class="line"><span class="lineno">  230</span>}</div>
<div class="ttc" id="async_8h_html_a179e079601e5f639db4748c5dcd70bbb"><div class="ttname"><a href="#a179e079601e5f639db4748c5dcd70bbb">snrt_wake_clusters</a></div><div class="ttdeci">void snrt_wake_clusters(uint32_t core_mask, snrt_comm_t comm=NULL)</div><div class="ttdoc">Wake the clusters belonging to a given communicator. Can only be called by a single core in the whole...</div><div class="ttdef"><b>Definition</b> sync.h:167</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a572ae0f42550fc0d5551f167f2f64a7d" name="a572ae0f42550fc0d5551f167f2f64a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572ae0f42550fc0d5551f167f2f64a7d">&#9670;&#160;</a></span>snrt_mutex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t * snrt_mutex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to a mutex variable. </p>
<div class="fragment"><div class="line"><span class="lineno">  107</span>{ <span class="keywordflow">return</span> &amp;_snrt_mutex; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a321bade577f4b200a5ad8aa37f281a61" name="a321bade577f4b200a5ad8aa37f281a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321bade577f4b200a5ad8aa37f281a61">&#9670;&#160;</a></span>snrt_mutex_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_acquire </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a mutex, blocking. </p>
<p>Test-and-set (TAS) implementation of a lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmtx</td><td>A pointer to a variable which can be used as a mutex, i.e. to which all cores have a reference and at a memory location to which atomic accesses can be made. This can be declared e.g. as <code>static volatile uint32_t mtx = 0;</code>. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  117</span>                                                        {</div>
<div class="line"><span class="lineno">  118</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(</div>
<div class="line"><span class="lineno">  119</span>        <span class="stringliteral">&quot;li            t0,1          # t0 = 1\n&quot;</span></div>
<div class="line"><span class="lineno">  120</span>        <span class="stringliteral">&quot;1:\n&quot;</span></div>
<div class="line"><span class="lineno">  121</span>        <span class="stringliteral">&quot;  amoswap.w.aq  t0,t0,(%0)   # t0 = oldlock &amp; lock = 1\n&quot;</span></div>
<div class="line"><span class="lineno">  122</span>        <span class="stringliteral">&quot;  bnez          t0,1b      # Retry if previously set)\n&quot;</span></div>
<div class="line"><span class="lineno">  123</span>        : <span class="stringliteral">&quot;+r&quot;</span>(pmtx)</div>
<div class="line"><span class="lineno">  124</span>        :</div>
<div class="line"><span class="lineno">  125</span>        : <span class="stringliteral">&quot;t0&quot;</span>);</div>
<div class="line"><span class="lineno">  126</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0c4e4b77fd2b4ce02f0235348745a57" name="ad0c4e4b77fd2b4ce02f0235348745a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c4e4b77fd2b4ce02f0235348745a57">&#9670;&#160;</a></span>snrt_mutex_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_release </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a previously-acquired mutex. </p>
<div class="fragment"><div class="line"><span class="lineno">  150</span>                                                        {</div>
<div class="line"><span class="lineno">  151</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;amoswap.w.rl  x0,x0,(%0)   # Release lock by storing 0\n&quot;</span></div>
<div class="line"><span class="lineno">  152</span>                 : <span class="stringliteral">&quot;+r&quot;</span>(pmtx));</div>
<div class="line"><span class="lineno">  153</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a25632cce8737bb2726e18ed1b4f267cf" name="a25632cce8737bb2726e18ed1b4f267cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25632cce8737bb2726e18ed1b4f267cf">&#9670;&#160;</a></span>snrt_mutex_ttas_acquire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_mutex_ttas_acquire </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *</td>          <td class="paramname"><span class="paramname"><em>pmtx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a mutex, blocking. </p>
<p>Same as snrt_mutex_acquire but acquires the lock using a test and test-and-set (TTAS) strategy. </p>
<div class="fragment"><div class="line"><span class="lineno">  133</span>                                                             {</div>
<div class="line"><span class="lineno">  134</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(</div>
<div class="line"><span class="lineno">  135</span>        <span class="stringliteral">&quot;1:\n&quot;</span></div>
<div class="line"><span class="lineno">  136</span>        <span class="stringliteral">&quot;  lw t0, 0(%0)\n&quot;</span></div>
<div class="line"><span class="lineno">  137</span>        <span class="stringliteral">&quot;  bnez t0, 1b\n&quot;</span></div>
<div class="line"><span class="lineno">  138</span>        <span class="stringliteral">&quot;  li t0,1          # t0 = 1\n&quot;</span></div>
<div class="line"><span class="lineno">  139</span>        <span class="stringliteral">&quot;2:\n&quot;</span></div>
<div class="line"><span class="lineno">  140</span>        <span class="stringliteral">&quot;  amoswap.w.aq  t0,t0,(%0)   # t0 = oldlock &amp; lock = 1\n&quot;</span></div>
<div class="line"><span class="lineno">  141</span>        <span class="stringliteral">&quot;  bnez          t0,2b      # Retry if previously set)\n&quot;</span></div>
<div class="line"><span class="lineno">  142</span>        : <span class="stringliteral">&quot;+r&quot;</span>(pmtx)</div>
<div class="line"><span class="lineno">  143</span>        :</div>
<div class="line"><span class="lineno">  144</span>        : <span class="stringliteral">&quot;t0&quot;</span>);</div>
<div class="line"><span class="lineno">  145</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a009fca3dd0749c28446bf4a9f86cb211" name="a009fca3dd0749c28446bf4a9f86cb211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009fca3dd0749c28446bf4a9f86cb211">&#9670;&#160;</a></span>snrt_partial_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_partial_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsnrt__barrier__t.html">snrt_barrier_t</a> *</td>          <td class="paramname"><span class="paramname"><em>barr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic software barrier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">barr</td><td>pointer to a barrier variable. </td></tr>
    <tr><td class="paramname">n</td><td>number of harts that have to enter before released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Exactly the specified number of harts must invoke this function, or the calling cores will stall indefinitely. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  310</span>                                                                   {</div>
<div class="line"><span class="lineno">  311</span>    <span class="comment">// Remember previous iteration</span></div>
<div class="line"><span class="lineno">  312</span>    uint32_t prev_it = barr-&gt;iteration;</div>
<div class="line"><span class="lineno">  313</span>    uint32_t cnt = __atomic_add_fetch(&amp;barr-&gt;cnt, 1, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  314</span> </div>
<div class="line"><span class="lineno">  315</span>    <span class="comment">// Increment the barrier counter</span></div>
<div class="line"><span class="lineno">  316</span>    <span class="keywordflow">if</span> (cnt == n) {</div>
<div class="line"><span class="lineno">  317</span>        barr-&gt;cnt = 0;</div>
<div class="line"><span class="lineno">  318</span>        __atomic_add_fetch(&amp;barr-&gt;iteration, 1, __ATOMIC_RELAXED);</div>
<div class="line"><span class="lineno">  319</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  320</span>        <span class="comment">// Some threads have not reached the barrier --&gt; Let&#39;s wait</span></div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">while</span> (prev_it == barr-&gt;iteration)</div>
<div class="line"><span class="lineno">  322</span>            ;</div>
<div class="line"><span class="lineno">  323</span>    }</div>
<div class="line"><span class="lineno">  324</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a02c67f898bda83ec08d38643eb4fc412" name="a02c67f898bda83ec08d38643eb4fc412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c67f898bda83ec08d38643eb4fc412">&#9670;&#160;</a></span>snrt_set_awuser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_set_awuser </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>field</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable LSU AW user field. </p>
<p>All stores performed after this call are equipped with the given AW user field</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>Defines the AW user field for the AXI transfer </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  464</span>                                            {</div>
<div class="line"><span class="lineno">  465</span>    write_csr(user_low, (uint32_t)(field));</div>
<div class="line"><span class="lineno">  466</span>    write_csr(user_high, (uint32_t)(field &gt;&gt; 32));</div>
<div class="line"><span class="lineno">  467</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a656ad0f51a364864f0e787eb27ec6d" name="a7a656ad0f51a364864f0e787eb27ec6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a656ad0f51a364864f0e787eb27ec6d">&#9670;&#160;</a></span>snrt_set_awuser_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_set_awuser_low </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>field</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  469</span>                                                {</div>
<div class="line"><span class="lineno">  470</span>    write_csr(user_low, (uint32_t)(field));</div>
<div class="line"><span class="lineno">  471</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6988e3d8671188ea63fa9a127963ebcb" name="a6988e3d8671188ea63fa9a127963ebcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6988e3d8671188ea63fa9a127963ebcb">&#9670;&#160;</a></span>snrt_wait_writeback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_wait_writeback </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure value is written back to the register file. </p>
<p>This function introduces a RAW dependency on val to stall the core until val is written back to the register file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The variable we want to wait on. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="lineno">  449</span>                                              {</div>
<div class="line"><span class="lineno">  450</span>    <span class="keyword">asm</span> <span class="keyword">volatile</span>(<span class="stringliteral">&quot;mv %0, %0&quot;</span> : <span class="stringliteral">&quot;+r&quot;</span>(val)::);</div>
<div class="line"><span class="lineno">  451</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a179e079601e5f639db4748c5dcd70bbb" name="a179e079601e5f639db4748c5dcd70bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179e079601e5f639db4748c5dcd70bbb">&#9670;&#160;</a></span>snrt_wake_clusters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void snrt_wake_clusters </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>core_mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnrt__comm__info__t.html">snrt_comm_t</a></td>          <td class="paramname"><span class="paramname"><em>comm</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wake the clusters belonging to a given communicator. Can only be called by a single core in the whole system! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comm</td><td>The communicator determining which clusters to wake up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When multicast is enabled the interrupt is sent also to the cluster invoking the function. As a consequence even the core invoking the function should clear its own interrupt. </dd></dl>
<div class="fragment"><div class="line"><span class="lineno">  167</span>                                                                            {</div>
<div class="line"><span class="lineno">  168</span>    <span class="comment">// If no communicator is given, world communicator is used as default.</span></div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">if</span> (comm == NULL) comm = snrt_comm_world;</div>
<div class="line"><span class="lineno">  170</span> </div>
<div class="line"><span class="lineno">  171</span><span class="preprocessor">#ifdef SNRT_SUPPORTS_NARROW_MULTICAST</span></div>
<div class="line"><span class="lineno">  172</span>    <span class="comment">// Multicast cluster interrupt to every other cluster&#39;s core</span></div>
<div class="line"><span class="lineno">  173</span>    <span class="keywordflow">if</span> (snrt_cluster_num() &gt; 0) {</div>
<div class="line"><span class="lineno">  174</span>        <span class="keyword">volatile</span> snitch_cluster_t *cluster = snrt_cluster(0);</div>
<div class="line"><span class="lineno">  175</span><span class="preprocessor">#pragma clang diagnostic push</span></div>
<div class="line"><span class="lineno">  176</span><span class="preprocessor">#pragma clang diagnostic ignored &quot;-Waddress-of-packed-member&quot;</span></div>
<div class="line"><span class="lineno">  177</span>        uint32_t *addr = (uint32_t *)&amp;(cluster-&gt;peripheral_reg.cl_clint_set.w);</div>
<div class="line"><span class="lineno">  178</span><span class="preprocessor">#pragma clang diagnostic pop</span></div>
<div class="line"><span class="lineno">  179</span>        uint32_t mcast_mask = snrt_get_collective_mask(comm);</div>
<div class="line"><span class="lineno">  180</span>        <a class="code hl_function" href="#aead031db6bba69af7489b18297b08d33">snrt_enable_multicast</a>(mcast_mask);</div>
<div class="line"><span class="lineno">  181</span>        *addr = core_mask;</div>
<div class="line"><span class="lineno">  182</span>        <a class="code hl_function" href="#ae3597f143342fb37d0564409eec33016">snrt_disable_multicast</a>();</div>
<div class="line"><span class="lineno">  183</span>    }</div>
<div class="line"><span class="lineno">  184</span><span class="preprocessor">#else</span></div>
<div class="line"><span class="lineno">  185</span>    <span class="comment">// Wake clusters sequentially.</span></div>
<div class="line"><span class="lineno">  186</span>    <span class="comment">// We find all clusters represented by the (base, mask) encoding through</span></div>
<div class="line"><span class="lineno">  187</span>    <span class="comment">// submask enumeration (https://codeforces.com/blog/entry/108942).</span></div>
<div class="line"><span class="lineno">  188</span>    uint32_t mask = comm-&gt;mask;</div>
<div class="line"><span class="lineno">  189</span>    uint32_t fixed = comm-&gt;base &amp; ~mask;</div>
<div class="line"><span class="lineno">  190</span>    uint32_t submask = 0;</div>
<div class="line"><span class="lineno">  191</span>    <span class="keywordflow">do</span> {</div>
<div class="line"><span class="lineno">  192</span>        uint32_t i = fixed | submask;</div>
<div class="line"><span class="lineno">  193</span>        <span class="keywordflow">if</span> (snrt_cluster_idx() != i) snrt_int_cluster_set(core_mask, i);</div>
<div class="line"><span class="lineno">  194</span>        submask = (submask - 1) &amp; mask;</div>
<div class="line"><span class="lineno">  195</span>    } <span class="keywordflow">while</span> (submask != 0);</div>
<div class="line"><span class="lineno">  196</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  197</span>}</div>
<div class="ttc" id="async_8h_html_ae3597f143342fb37d0564409eec33016"><div class="ttname"><a href="#ae3597f143342fb37d0564409eec33016">snrt_disable_multicast</a></div><div class="ttdeci">void snrt_disable_multicast()</div><div class="ttdoc">Disable LSU multicast.</div><div class="ttdef"><b>Definition</b> sync.h:498</div></div>
<div class="ttc" id="async_8h_html_aead031db6bba69af7489b18297b08d33"><div class="ttname"><a href="#aead031db6bba69af7489b18297b08d33">snrt_enable_multicast</a></div><div class="ttdeci">void snrt_enable_multicast(uint64_t mask)</div><div class="ttdoc">Enable LSU multicast.</div><div class="ttdef"><b>Definition</b> sync.h:488</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae3a9acd2f4afcb8d04b26fea730129a8" name="ae3a9acd2f4afcb8d04b26fea730129a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9acd2f4afcb8d04b26fea730129a8">&#9670;&#160;</a></span>snrt_comm_world_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__thread <a class="el" href="structsnrt__comm__info__t.html">snrt_comm_info_t</a> snrt_comm_world_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">   14</span>                                                 {</div>
<div class="line"><span class="lineno">   15</span>    .barrier_ptr = &amp;(_snrt_barrier.cnt),</div>
<div class="line"><span class="lineno">   16</span>    .size = SNRT_CLUSTER_NUM,</div>
<div class="line"><span class="lineno">   17</span>    .mask = SNRT_CLUSTER_NUM - 1,</div>
<div class="line"><span class="lineno">   18</span>    .base = 0,</div>
<div class="line"><span class="lineno">   19</span>    .is_participant = 1};</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
